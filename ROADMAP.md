План работы
-----------
* перечитать и обновить тексты
  * уйти от терминов операционной системы и языка программирования
  * оформить ревизию 2
  * залить изменения
* перечитать все формулировки и сделать ревизию 3
  * особое внимание - на мотивацию и цель
  * подтвердить целостность технической терминологии
  * залить изменения
* начать dom+svg реализацию knoxel space в новых терминах
  * но по мотивам старого плана, который достался от WebGL/ThreeJS-версии
  * так как я пришёл к выводу, что ускорение отрисовки сейчас не главное
* вынести план работ в отдельный файл
* создание knoxel'ей в space по клику
* применение описательной схемы для определения вида элементов и пространства
* автоматическое растягивание visualRoot на полный экран
* knoxel space как содержимое knoxel'я
  * создавать идентифицируемые rect'ы рандомного цвета при фиксированном цвете обводки
  * выбирать тот rect, который станет активным спейсом и развернётся на весь экран
    * по клику
    * через консольную команду по id rect'а
  * в runtime хранить в каждом rect'е его собственное подпространство
    * тогда через консоль можно будет произвольно путешествовать по всем созданным в runtime rect'ам
  * стартовать с пары смотрящих друг на друга knoxel'ей
  * при входе внутрь пространства knoxel'я автоматически создавать обратную связь
    * чтобы все пространства были визуально связаны между собой и нельзя было бы попасть в тупик
  * придумать как перемещаться между rect'ами через визуальный интерфейс
    * обходиться для навигации без консольных команд и знания обо всех id rect'ов
      * по факту автоматическая связность пространств позволяет осуществлять необходимую навигацию
* ввести knyte'ы как источники knoxel'ей
  * knyte обладает цветом фона в качестве information record'а
  * определение knyte'ов через knit'ы
  * рефакторинг knit'а как singleton и параметров функций addKnoxel, addRect, restoreRect
  * создание как новых knyte'ов, так и дополнительных knoxel'ей для существующих knyte'ов
    * cmd+click - новый knyte и knoxel для него
    * alt+click на knoxel'е - новый новый для его knyte'а
    * alt+click на root space'е - новый новый для knyte'а root space'а
  * привязка space'ов к knyte'ам вместо knoxel'ей
  * рефакторинг - во всех переменных типа rootId указывать что это за id: knyte/knoxel/element/etc.
  * быстрая реализация кнопки "назад" для навигации по пространствам
  * решить вопрос с неконтролируемым и потенциально бесконечным заползанием внутрь одного и того же knoxel'я
    * происходит, если кликать на его rect по многу раз
  * рефакторинг onLoadBody -> rootKnyteId/rootKnoxelId/rootColor
    * слово root тут не подходит, надо найти что-то типа origin как пару для mirror
  * перенос knoxel'ей внутри пространства и между пространствами
    * через drag'n'drop
      * с возможностью прервать операцию escape'ом
      * с возможностью прилепить ghost к screenspace'у space'ом для перемещения на далёкие расстояния и в другие пространства
    * рефакторинг параметров для addRect, spawnGhostRect, onGhostRectMoved
    * рефакторинг логики onGhostRectMoved для упрощения и наглядности
    * багфикс: попытка перемещение rect'а drag'n'drop'ом на малое расстояние приводит к проваливанию в его пространство
      * в итоге была переделана вся система перемещений и завязана на space/escape. подробности в readme.
    * багфикс: создаю knoxel для текущего space root, захожу в него, пытаюсь переместить
      * визуально действие по перемещению прерывается, но при обновлении space'а оно оказывается применённым
      * причина в том, что в этой ситуации в DOM'е существует 2 элемента с одинаковым id: spaceRoot и перемещаемый rect
        * надо на концептуальном уровне решить что делать с этими id
          * есть идея просто-напросто не отрисовывать knoxel с тем же id, что и у spaceRoot
            * в итоге так и сделал - посмотрим к чему это приведёт
* перевод knoxel'ей из worldspace в screenspace и обратно
  * в первую очередь подумать нужно ли это вообще или обойдёмся тем что уже есть
  * по итогам размышлений мысли следующие
    * не видно смысла в особом статусе screenspace'а.
    * если позволить делать интерактивное управление из одного пространства в другом,
    * то аналог скринспейса можно соорудить из простых knoxel'ей.
    * по факту сейчас screenspace нужен только для глобальных элементов управления:
      * space back arrow
      * save/load file (когда потребуется)
* способ управления порядком следования rect'ов в сцене
  * чтобы можно было удобно управлять кто кого перекрывает при отрисовке
  * по сути эту функцию может выполнять взятие и установка на место knoxel'я в режиме перемещения
    * можно пользоваться двойным нажатием space для вывода knoxel'я на верхний уровень отрисовки
    * единственное, что мешает этому сейчас, - это смещение ghost'а относительно knoxel'я при старте перемещения
      * фиксим эту проблему
      * и также рисуем специальным образом knoxel, для которого начато перемещение
        * stroke-dasharray="0 16" stroke-linecap="square"
      * отрефакторить работу с ghost - урегулировать новый функционал
        * в том числе отладить сложные случаи работы с knoxel'ями одного и того же knyte'а
          * сейчас там нет критических багов, но всё выглядит странно и сделано быстрыми хаками
        * подумать что делать с возможностью создавать "пространственные острова"
          * когда в мастер-пространстве создаёшь 2 knoxel'я
          * и потом вкладываешь их один в другой
          * в итоге если выйти из них через space back в мастер-пространство, то обратно в них уже не попасть
          * решение
            * в итоге для полного контроля над пространством нужно сделать 3 внешние ui-кнопки
              * space back - уже есть
              * space forward - действие обратное space back.
                * то есть возврат обратно в пространство, из которого вышел по space back
                * при этом последовательность space forward'ов обнулится, если войти в новое пространство
                  * это аналогично работе undo/redo в текстовом редакторе
              * space map - карта всех связанных через пространство knoxel'ей
                * чтобы можно было видеть все knoxel'и пространства и образованные ими острова
            * реализация
              * space forward
                * нарисовать в вёрстке
                * подправить функционал space back
                * прикрутить функционал space forward
              * space map
                * нарисовать в вёрстке
                * придумать как вписать в концепцию пространства
                  * добавляем третий особый knoxel в knoxel space
                    * в дополнение к master-knoxel и mirror-knoxel
                    * он будет называться spacemap-knoxel
                      * его контент генерируется при входе в него автоматически
                      * алгоритм генерации контента группирует все knoxel'и по связным группам
                        * такие группы называются островами
                      * таким образом из spacemap можно перейти в любой knoxel
                        * не зависимо от того, связан он с островом master-knoxel'я или нет
                * базовый реализовать функционал
                * довести фичу до законченного вида
                  * не всегда разделение на острова идёт корректно
                    * бывает, что появляются странные острова с одним knoxel'ем
                    * или один и тот же knoxel входит сразу в несколько островов
                      * по всей видимости это происходит от того, 
                      * что не любой knoxel может стать родоначальником острова.
                      * надо, чтобы в пространстве knoxel'я были другие элементы.
                      * если же он сам пустой, но содержится в пространствах других knoxel'ей,
                      * то его нельзя брать за первый knoxel острова
                    * таким образом, выбирать первый knoxel острова нужно специальным образом
                  * наилучший способ работы кнопок навигации при совместном использовании
                    * space map, space back, space forward
                      * в итоге space map получил поведение шортката для особого space map knoxel'я
                      * в целом его пространство ведёт себя как пространство стандартного knoxel'я
        * `пересмотреть весь код и сделать его более логичным и понятным`
          * потому что последние изменения для управления слоями порядком запутали логику кода
* реализовать отрисовку knoxel'ей
  * innerspace
    * рекурсия отрисовки внутреннего пространства knoxel'я
      * решить как будет задаваться размер knoxel'я в каждом пространстве
        * пока что видно два основных варианта:
          * автоопределение размера по размеру внутреннего пространства
          * ручное задание собственного размера в каждом пространстве, храненить рядом с позицией
      * отрисовка внутренностей без скейлов
      * введение навигации и реализация отрисовки с соответствующим ей скейлом
  * information record
  * vector
  * и всё вместе в любой комбинации
* пространственная навигация по пространствам knoxel'ей
* множественное выделение knoxel'ей и совместимость с ним всех реализованных функций
