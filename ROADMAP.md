План работы
-----------
* перечитать и обновить тексты
  * уйти от терминов операционной системы и языка программирования
  * оформить ревизию 2
  * залить изменения
* перечитать все формулировки и сделать ревизию 3
  * особое внимание - на мотивацию и цель
  * подтвердить целостность технической терминологии
  * залить изменения
* начать dom+svg реализацию knoxel space в новых терминах
  * но по мотивам старого плана, который достался от WebGL/ThreeJS-версии
  * так как я пришёл к выводу, что ускорение отрисовки сейчас не главное
* вынести план работ в отдельный файл
* создание knoxel'ей в space по клику
* применение описательной схемы для определения вида элементов и пространства
* автоматическое растягивание visualRoot на полный экран
* knoxel space как содержимое knoxel'я
  * создавать идентифицируемые rect'ы рандомного цвета при фиксированном цвете обводки
  * выбирать тот rect, который станет активным спейсом и развернётся на весь экран
    * по клику
    * через консольную команду по id rect'а
  * в runtime хранить в каждом rect'е его собственное подпространство
    * тогда через консоль можно будет произвольно путешествовать по всем созданным в runtime rect'ам
  * стартовать с пары смотрящих друг на друга knoxel'ей
  * при входе внутрь пространства knoxel'я автоматически создавать обратную связь
    * чтобы все пространства были визуально связаны между собой и нельзя было бы попасть в тупик
  * придумать как перемещаться между rect'ами через визуальный интерфейс
    * обходиться для навигации без консольных команд и знания обо всех id rect'ов
      * по факту автоматическая связность пространств позволяет осуществлять необходимую навигацию
* ввести knyte'ы как источники knoxel'ей
  * knyte обладает цветом фона в качестве information record'а
  * определение knyte'ов через knit'ы
  * рефакторинг knit'а как singleton и параметров функций addKnoxel, addRect, restoreRect
  * создание как новых knyte'ов, так и дополнительных knoxel'ей для существующих knyte'ов
    * cmd+click - новый knyte и knoxel для него
    * alt+click на knoxel'е - новый новый для его knyte'а
    * alt+click на root space'е - новый новый для knyte'а root space'а
  * привязка space'ов к knyte'ам вместо knoxel'ей
  * рефакторинг - во всех переменных типа rootId указывать что это за id: knyte/knoxel/element/etc.
  * быстрая реализация кнопки "назад" для навигации по пространствам
  * решить вопрос с неконтролируемым и потенциально бесконечным заползанием внутрь одного и того же knoxel'я
    * происходит, если кликать на его rect по многу раз
  * рефакторинг onLoadBody -> rootKnyteId/rootKnoxelId/rootColor
    * слово root тут не подходит, надо найти что-то типа origin как пару для mirror
  * перенос knoxel'ей внутри пространства и между пространствами
    * через drag'n'drop
      * с возможностью прервать операцию escape'ом
      * с возможностью прилепить ghost к screenspace'у space'ом для перемещения на далёкие расстояния и в другие пространства
    * рефакторинг параметров для addRect, spawnGhostRect, onGhostRectMoved
    * рефакторинг логики onGhostRectMoved для упрощения и наглядности
    * багфикс: попытка перемещение rect'а drag'n'drop'ом на малое расстояние приводит к проваливанию в его пространство
      * в итоге была переделана вся система перемещений и завязана на space/escape. подробности в readme.
    * багфикс: создаю knoxel для текущего space root, захожу в него, пытаюсь переместить
      * визуально действие по перемещению прерывается, но при обновлении space'а оно оказывается применённым
      * причина в том, что в этой ситуации в DOM'е существует 2 элемента с одинаковым id: spaceRoot и перемещаемый rect
        * надо на концептуальном уровне решить что делать с этими id
          * есть идея просто-напросто не отрисовывать knoxel с тем же id, что и у spaceRoot
            * в итоге так и сделал - посмотрим к чему это приведёт
* перевод knoxel'ей из worldspace в screenspace и обратно
  * в первую очередь подумать нужно ли это вообще или обойдёмся тем что уже есть
  * по итогам размышлений мысли следующие
    * не видно смысла в особом статусе screenspace'а.
    * если позволить делать интерактивное управление из одного пространства в другом,
    * то аналог скринспейса можно соорудить из простых knoxel'ей.
    * по факту сейчас screenspace нужен только для глобальных элементов управления:
      * space back arrow
      * save/load file (когда потребуется)
* способ управления порядком следования rect'ов в сцене
  * чтобы можно было удобно управлять кто кого перекрывает при отрисовке
  * по сути эту функцию может выполнять взятие и установка на место knoxel'я в режиме перемещения
    * можно пользоваться двойным нажатием space для вывода knoxel'я на верхний уровень отрисовки
    * единственное, что мешает этому сейчас, - это смещение ghost'а относительно knoxel'я при старте перемещения
      * фиксим эту проблему
      * и также рисуем специальным образом knoxel, для которого начато перемещение
        * stroke-dasharray="0 16" stroke-linecap="square"
      * отрефакторить работу с ghost - урегулировать новый функционал
        * в том числе отладить сложные случаи работы с knoxel'ями одного и того же knyte'а
          * сейчас там нет критических багов, но всё выглядит странно и сделано быстрыми хаками
        * подумать что делать с возможностью создавать "пространственные острова"
          * когда в мастер-пространстве создаёшь 2 knoxel'я
          * и потом вкладываешь их один в другой
          * в итоге если выйти из них через space back в мастер-пространство, то обратно в них уже не попасть
          * решение
            * в итоге для полного контроля над пространством нужно сделать 3 внешние ui-кнопки
              * space back - уже есть
              * space forward - действие обратное space back.
                * то есть возврат обратно в пространство, из которого вышел по space back
                * при этом последовательность space forward'ов обнулится, если войти в новое пространство
                  * это аналогично работе undo/redo в текстовом редакторе
              * space map - карта всех связанных через пространство knoxel'ей
                * чтобы можно было видеть все knoxel'и пространства и образованные ими острова
            * реализация
              * space forward
                * нарисовать в вёрстке
                * подправить функционал space back
                * прикрутить функционал space forward
              * space map
                * нарисовать в вёрстке
                * придумать как вписать в концепцию пространства
                  * добавляем третий особый knoxel в knoxel space
                    * в дополнение к master-knoxel и mirror-knoxel
                    * он будет называться spacemap-knoxel
                      * его контент генерируется при входе в него автоматически
                      * алгоритм генерации контента группирует все knoxel'и по связным группам
                        * такие группы называются островами
                      * таким образом из spacemap можно перейти в любой knoxel
                        * не зависимо от того, связан он с островом master-knoxel'я или нет
                * базовый реализовать функционал
                * довести фичу до законченного вида
                  * не всегда разделение на острова идёт корректно
                    * бывает, что появляются странные острова с одним knoxel'ем
                    * или один и тот же knoxel входит сразу в несколько островов
                      * по всей видимости это происходит от того, 
                      * что не любой knoxel может стать родоначальником острова.
                      * надо, чтобы в пространстве knoxel'я были другие элементы.
                      * если же он сам пустой, но содержится в пространствах других knoxel'ей,
                      * то его нельзя брать за первый knoxel острова
                    * таким образом, выбирать первый knoxel острова нужно специальным образом
                  * наилучший способ работы кнопок навигации при совместном использовании
                    * space map, space back, space forward
                      * в итоге space map получил поведение шортката для особого space map knoxel'я
                      * в целом его пространство ведёт себя как пространство стандартного knoxel'я
        * пересмотреть весь код и сделать его более логичным и понятным
          * потому что последние изменения для управления слоями порядком запутали логику кода
* оценка целостности логики управления пространством
  * что делать с ситуацией, когда knyte-пространство root space knoxel'я содержит в себе его самого?
    * описание проблемы
      * чисто технически получается, что в сцене 2 элемента с одинаковым id
      * поэтому как быстрое решение была отключена отрисовка такого knoxel'я внутри его пространства
      * ссылка на код:
        * if (knoxelId === newKnoxelId) // don't show knoxel inside itself
      * это приводит к эффекту исчезания и появления knoxel'ей при переключении space root'а.
      * нужно подумать как можно иначе решить эту проблему, чтобы всё работало проще и нагляднее.
    * решение
      * использовать в spaceRootElement не .id, а .dataset.knoxelId для хранения соответствующего knoxelId
        * таким образом можно избежать технического конфликта идентификации
        * такое логически допустимо, потому что .id используется для knoxel'ей внутри spaceRootElement
      * в итоге убираем функционал don't show knoxel inside itself
      * решаем сопутствующие проблемы
        * если попытаться переместить по пробелу knoxel, который и внутри пространства, и является его root'ом
          * то начнутся глюки, потому что такая ситуация не обрабатывается логикой переноса
          * в итоге внесены изменения, которые учитывают новые варианты структуры пространства
        * если в пространстве несколько knoxel'ей с таким же knyte'ом как и у root'а
          * то при перещёлкивании между ними мы не видим разницы, как-будто ничего не происходит
          * раньше они хотя бы исчезали и появлялись, была видна какая-то динамика
          * вероятно, надо особым образом рисовать и управлять knoxel'ем, который является root'ом
            * в итоге решил рисовать скругление прямоугольника через rx
              * это не окончательный вариант, но самый простой в реализации
              * в дальнейшем при переходе от rect к комплексным геометриям для отрисовки knoxel'ей
                * можно опдумать о более наглядном способе показать самовложенность knoxel'я
  * не всё понятно с функцией перемещения knoxel'я
    * когда надо переместить его внутри того же пространства, то всё просто и наглядно
    * когда knoxel в другом пространстве, где не виден gosted knoxel, возможны ситуации
      * при завершении операции не совсем понятно что произошло именно перемещение, а не копирование
      * при отмене операции не совсем понятно, что ghost knoxel остался на старом месте, а не удалён
    * решение
      * можно добавить специальную навигационную кнопку, которая покажет пространство ghost host knyte'а
        * на случай, если пользователь забыл откуда взял knoxel'и для переноса
        * и не понимает что с ними делать: копировать, перемещать или отменять операцию
      * вариант интерактива 1
        * onmousedown рисуется host-пространство
        * onmouseup возвращается отрисовка актуального space root'а
      * вариант интерактива 2
        * кнопка является шорткатом для перепрыгивания в host-пространство
        * вернуться обратно после просмотра можно по кнопке space back
    * реализация
      * в итоге сделан второй вариант как наиболее унифицированный с имеющимися решениями
  * по логике работы space map из него невозможно вытащить knoxel в другое пространство
    * логика сбора связей работает на knyte'ах, но отрисовка происходит по knoxel'ям
      * то есть не совсем понятна для чего рисуется карта и как определяются острова
        * разобравшись, я понял что остров - это не тот набор knoxel'ей, в которые можно попасть,
        * а это набор связанных knoxel'ей. при этом пока что мы можем ходить только в одном направлнии связи.
        * то есть может быть ситуация, что knoxel включён в остров, но в него нельзя попасть
        * пользуясь стандартными средствами навигации.
        * в перспективе можно развить инструменты так, чтобы можно было перемещаться по всем knoxel'ям острова.
    * особенности работы функций редактирования пространства в space map
      * создание knoxel'я внутри space map
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * копирование knoxel'я внутри space map
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * перенос knoxel'я внутри space map
        * визуально перенос не производится, так как происходит buildSpaceMap при обновлении вида пространства
          * не перестраиваем space map при вызове setSpaceRootKnoxel в целях обновления пространства
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * копирование knoxel'я в space map из любого другого пространства
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * перенос knoxel'я из space map в другое пространство
        * работает адекватно
      * перенос knoxel'я из другого пространства в space map
        * на данный момент это действие отрывает knoxel от родного острова
        * но если переместить его же внутри space map, то никакого отрыва не будет.
        * нужно чтобы при любом варианте начала перемещения проиходило одно и то же действие
          * knoxel должен просто перемещаться в пространстве space map'а без смены host knoxel'я
    * нужно добавить визуализацию вложенностей пространств через стрелки
      * иначе совершенно не понятна структура островов и карта выглядит бессмысленной.
      * описание проблемы
        * стрелки должны быть отдельным типом объектов, отличным от векторов, которые появятся в перспективе.
        * на уровне отрисовки стрелки и векторы одинаковы, но на уровне логики они разные.
        * в space map нет смысла отображать knoxel'и в виде векторов
          * игнорируются все связи между knoxel'ями, кроме вложенностей
      * реализация
        * обобщённый функционал отрисовки arrow между rect'ами в условиях перемещения
          * arrow между arrow пока не нужны
          * создание arrow фиксированного цвета
          * обновление формы arrow при перемещении rect'ов
        * рефакторинг arrow - чтобы её концы были в центре rect'ов, а не по левому верхнему углу
        * прикручивание arrow к rect'ам в space map
    * перенос и копирование knoxel'я space map в пространства других knoxel'ей
      * нужно подумать возможно ли такое
        * и если нет, то запретить на уровне интерфейса
      * так как space map - это особый knoxel, выпадающий их общей концепции
        * запрещаем его перенос и копирование в какие-либо пространства
      * попутно обнаружилось, что если переносить knoxel из space map в другой knoxel
        * то knoxel начинает принадлежать сразу 2 пространствам: старому и новому,
        * потому что host определяется неправильно и из него ссылка на knoxel не удаляется.
        * но по концепции пространств knoxel в один момент времени может находиться
          * не более чем в 1 пространстве, не считая пространство space map'а.
        * решение - запретить перемещать любые knoxel'и из space map в другие пространства
  * не хватает возможности удаления knoxel'ей и knyte'ов для полного набора операций
    * решение должно обязательно избегать проблемы контроля того, что именно удаляется
      * как минимум не понятно удаляется только knoxel или весь knyte - должно быть однозначное правило
    * сразу приходят сопутствующие вопросы
      * какое удаление будет применяться по умолчанию?
      * что делать, если для knyte'а удалили все knoxel'и и он больше не имеет визуального представления?
      * как просто удалить все knoxel'и для заданного knyte'а?
    * в голову пришло необычное решение
      * вместо удаления можно перетаскивать ненужные knoxel'и на остров-мусорку
      * у ненужных knoxel'ей обрезаются все связи, очищается весь контент и они убираются в отдельное пространство
        * и это пользователь делает вручную или с помощью собственных кастомных алгоритмов,
        * потому что в общем случае корректное автоматическое отвязывание реализовать нельзя
  * обдумать функционирование space map
    * создание mirror-knoxel'я на старте уже не выглядит необходимым для взгляда со стороны на master-knoxel
      * благодаря наличию space map knoxel'я принудительное создание зеркала уже не нужно
    * оформить противоречия в текущей концепции space map'а
      * не очень понятно зачем нужно создавать и копировать knoxel'и внутри space map
        * если изначально он создавался для обзора пространственной структуры
      * не понятно почему в space map добавляются точно те же knoxel'и, что и в других пространствах, а не их копии
        * ведь это нарушает принцип что knoxel должен содержаться не более чем в 1 пространстве
      * может быть есть смысл прийти к принципу, что knoxel всегда должен содержаться в 1 и только 1 пространстве
        * тогда придётся вернуть mirror-knoxel и пересмотреть принципы работы space map
    * возможное решение
      * попробовать сделать space map для knyte'ов, а не для knoxel'ей
      * создать полную копию space как space2
      * удалить из space2 старую реализацию space map
      * написать с нуля новую реализацию
        * в которой space map - это такой же knyte с knoxel'ями
        * но у которого автоматически обновляется space при каждом изменении knyte space'а
        * поправить трейс arrow - чтобы они не перекрывали rect'ы
        * прятать arrow когда не отображается spacemap
        * решить как в spacemap будут себя вести knoxel'и оригиналы и дубликаты для knyte'ов
          * knoxel'и оригиналы можно создавать прямо в spacemap без проблем.
          * пока что концепция spacemap рассчитана на то, что каждый knyte представлен одним единственным knoxel'ем,
            * но в концепции обобщённого knoxel-пространства можно создавать дополнительные knoxel'и для knyte'ов.
            * надо подумать как это можно разрулить оставаясь в рамках правил spacemap'а.
              * в итоге разрешено делать перенос и копию knoxel'ей, для них создаются knyte-based arrows.
              * с одной стороны это не нарушает общую концепцию пространства и все функции разрешены,
              * с другой стороны можно легко навертеть очень запутанную структуру.
                * время покажет как лучше это всё организовывать, пока оставим так.
        * подобрать оптимальную цветовую схему
          * сейчас схема читаемая, но очень страшная. надо сделать более гармоничную.
          * вроде бы получше стало, жить можно, едем дальше.
        * сравнить поведение spacemap'ов в реализациях space/ и space2/
          * понять какое из них более адекватно потребностям пользователя
          * по факту проверки space2/ гораздо адекватнее и удобнее
            * поэтому переходим на него как на главное решение
        * рефакторинг применения spacemap и onKnoxelSpaceChanged
          * чтобы spacemap knoxel максимально гармонично вписывался в общую концепцию knoxel'ей
        * реализовать arrow у которого initial === terminal
          * то есть наглядно отрисовывать связь rect'а самого на себя
            * решил сделать по-простому - нарисовать arrow внутри rect'а, а не вести по внешнему контуру
            * для текущей ситуации пойдёт, а в будущем можно переделать в зависимости от ситуации
          * заодно нашёл и пофиксил дублирование при создании arrows
        * более наглядное отображение arrow - соединять не центры, а края rect'ов
          * удалось реализовать точное позиционирование стрелок с помощью модуля intersect
        * новые мысли про жизненный цикл knyte'ов и knoxel'ей
          * исходя из базовой концепции можно создавать knyte'ы
            * но нет универсального и удобного способа их удалять
          * так же для каждого knyte'а должен существовать как минимум 1 knoxel для отображения и манипуляций
            * но можно создать и много knoxel'ей - каждый в своём контексте и со своими настройками
            * при этом легко наплодить множество мусорных knoxel'ей для одного единственного knyte'а
            * чтобы избавляться от ненужных knoxel'ей, можно ввести операцию объединения knoxel'ей одного и того же knyte'а
          * получается, что изначально knyte создаётс с одним единственным knoxel'ем
            * затем этот knoxel может быть расщиплён для создания большего количества отображений knyte'а
            * а когда нужно сделать меньше отображений для knyte'а, то его knoxel' могут быть объединены
          * есть смысл переделать всё управление под новую концепцию, добавив функцию объединения
          * первым дело реализуем функцию объединения на случайном шорткате
            * описание работы
              * объединение действует из режима ghost
              * если наводим ghost на knoxel, с которым его можно объединить, то показывается подсказка
              * alt+space объединяет target-knoxel и ghosted knoxel
            * визуальная отработка интерфейса
            * отработка на уровне логики
            * рефакторинг для перехода от концепции add/remove к концепции divide/join в коде
          * далее заменяем функцию копирования (ghost: alt+click) на функцию расщипления
            * срабатывает при alt+click на knoxel'е - добавляет рядом второй knoxel для того же knyte'а
          * в итоге доводим до ума весь комплекс шорткатов, чтобы они имели смысл и были удобными
            * спроектировать
              * отделить операции divide/join от ghost-режима в отдельный bubble-режим
                * который запускается по кнопке enter
              * при нажатии enter из bubble-режима на пустом месте делается divide
              * при нажатии enter из bubble-режима на другом knoxel'е того же knyte'а делается join
              * при нажатии esc из bubble-режима происходит выход из этого режима
              * при нажатии enter из bubble-режима на том же самом knoxel'е происходит выход из этого режима
            * реализовать
              * функционал на кнопках
              * интуитивно понятное отображение
                * разрулить особый кейс, когда делается join для space root knoxel'я
                  * запретить join для space root'а
                  * если нужно убрать knoxel, сначала назначается другой space root
                * перейти от кешированного mouseoverKnoxelId на актуальный через document.elementFromPoint
                  * это поправит следующие баги:
                    * если создать knoxel и сразу нажать space
                      * то ghost создастся не для него а для того, что лежит под ним,
                      * потому что из-за отстутствия события onMouseOverRect не обновится mouseoverGhostKnoxelId
                    * если сделать join для knoxel'я, mouseoverKnoxelId всё равно будет указывать на него
                      * не смотря на то, что он исчез
                * в bubble-режиме действуют следующие правила особые отображения для knoxel'ей:
                  * active bubble полупрозрачный и с пунктирным контуром
                  * knoxel'и с тем же knyte'ом но не равные исходному - с пунктирным контуром
                  * всё остальное рисуется без изменений
            * обновить описание управления в readme
          * переосмыслить реакцию на space на пустом месте
            * интерпретация пустого места в ghost- и bubble- режимах должна быть идентичной
              * в целом получилось, что они ведут себя примерно одинаково, концептуальных противоречий не замечено
            * багфикс - если взять ghost из space root и переместить его в 2 разных knoxel'я
              * то space root knoxel окажется сразу в 2 пространствах
                * что противоречит концепции пространства как контейнера для knoxel'ей
            * багфикс - если взять bubble от space root
              * навести его на knoxel другого knyte'а и нажать enter
              * будет произведён divide actual bubble, хотя по логике вещей ожидается terminate
            * багфикс - некорректная отрисовка и поведение selfcontained-knoxel'я в bubble-режиме
              * он не должен быть пунктирным, потому что он не может быть уничтожен
              * при enter на нём не должен создаваться новый knoxel, а должен происходить terminate
          * переосмыслить скругление rect'а при отрисовке knoxel'я совпадающего со space root'ом
            * я не думаю, что в общем случае мы можем менять форму rect'а
            * да и сама визуализация не особо репрезентативная
              * в итоге перешёл от скруглений к утончению обводки
                * думаю, как временный вариант - вполне нормально
* фиксируем полезное допущение
  * пусть содержимое пространства любого knyte'а умещается в пределах экрана браузера
  * тогда не треуется делать множество дополнительных инструментов для работы в большом пространстве
  * и можно уделить основное внимание локальной реализации взаимодействия функций в семантической среде
  * когда все основные функции локального knoxel space'а будут готовы
    * можно будет наложить на них концепцию "широкого пространства", выходящего за границы экрана
* реализовать отрисовку knoxel'ей
  * innerspace
    * рекурсия отрисовки внутреннего пространства knoxel'я
      * решить как будет задаваться размер knoxel'я в каждом пространстве
        * пока что видно два основных варианта:
          * автоопределение размера по размеру внутреннего пространства
          * ручное задание собственного размера в каждом пространстве, храненить рядом с позицией
      * отрисовка внутренностей без скейлов
        * погружение всего на 1 уровень внутрь
          * автоопределение размеров по содержимому
          * игнорирование цикличных кейсов, то есть расчитано только под древовидное ветвление
          * особая отрисовка для knoxel'ей space map'а
        * погонять функционал и понять что ещё может минимально понадобиться для первой демки
        * специальное отображение пространств space map'а
        * отображение пространств с неограниченной вложенностью для древовидного вида связности
          * основная реализация
          * поддержка иконок внутри пространств
        * специальное отображение пространств для кольцевой и самосодержащейся вложенности
        * выравнивание размера пространств по левому верхнему краю
          * не только по правому нижнему как это сделано сейчас
          * подпространства не должны вылазить за левый верхний край
          * подпространства не должны иметь неоправданную пустоту в левой верхней части
        * понять как быть с циклическими вложенностями
          * у них есть тенденция постоянно расширяться в пространстве
          * глядя на них, не понятно что там происходит
            * благодаря удачной системе автоопределения размера пространств циклические вложенности на создают проблем
        * вероятно, есть смысл рисовать шейпы внутри активных knoxel'ей с более тонкой рамкой
          * чтобы было понятно, что это отображения, а не активные элементы
          * тогда надо придумать другое отображение для selfcontained knoxel
            * чтобы ему не приходилось утончать обводку, тем самым внося путаницу в интерфейс
            * в итоге реализовано наложение крестообразного выделения на rect knoxel'я
          * провести эксперимент с изменением толщины обводок внутри активных knoxel'ей
            * реализовал, посмотрел - выглядит отлично. оставляем так.
        * иногда при выборе пространства как ghost/bubble нельзя войти по клику в другое пространство
          * вся проблема в том, что не на все элементы выставляется pointer-events: none
        * при нажатии space/enter на selfcontained knoxel должен появляться ghost/bubble строго поверх него
          * а не по середине курсора. такое поведение мешает управлять порядком слоёв
        * подумать что делать при переносе ghost/bubble между пространствами
          * у них может меняться актуальное отображение в зависимости от space root'а
            * а сейчас это не учитывается, в итоге можно видеть на превью одна, а в пространство воткнуть другое
          * решение: надо пересоздавать визуализацию для ghost/bubble при каждой смене пространства
            * таким образом в каждом пространстве будет показываться соответствующее ему отображение knoxel'я
          * реализация
            * ghost
            * bubble
     * по завершению вышеперечисленных этапов можно организовать демонстрации текущего состояния системы
  * information record
    * продумать саму концепцию внедрения контента внутрь svg-объектов
      * вероятно, нужно всё делать через foreignObject и дать возможность задавать knoxel'ям произвольный html-контент
      * также нужно изучить возможности современных стандартов svg и их взаимодействие с html и css
        * рассмотреть вариант перехода с текущей версии svg 1.1 на самую свежую
          * узнать какая вообще версия является последней
          * проверить совместимость с браузерами
          * понять какие профиты будут от новой версии
          * оценить масштаб переделок
            * в итоге оказалось, что приемником актуального svg 1.1 станет svg 2.0, который ещё не готов
            * поэтому остаёмся на svg 1.1
        * выработать наиболее эффективный способ внедрения обобщённого html+css+js внутрь svg-элементов knoxel'ей
          * делать ли оптимизацию структуры svg-елементов под контент (пусто, однострочный текст, foreignObject)
            * или везде использовать foreignObject, чтобы не перестраивать их структуру при каждом изменении контента?
          * стресс-тесты показали, что добавление foreignObject к 10000 rect'ов не приводит к сильному замедлению сцены
            * соответственно можно использовать унифицированную модель rect'а для всех ситуаций
          * для начала делаем конкуретный способ отрисовки контента, чтобы на нём уже пробовать все идеи
            * конкуретный - это значит что если у knyte'а есть information record, то рисуется только он
              * в противном случае рисуется innerspace
            * реализация на базовом уровне
            * автоопределение размера контента и выравнивание по нему foreignObject'а
              * через element.getBoundingClientRect
              * в общем случае это невозможно, поэтому перейдём к ручному заданию размеров каждого foreignObject'а
            * выравнивание размера rect'а по foreignObject'у
              * при этом rect не должен быть меньше заданных минимальных размеров visualTheme.rect.defaultWidth/Height
          * как выравнивать контент внутри rect'а для лучшей читаемости?
            * особенно важно в том случае, если контент по размеру оказался меньше rect'а
              * общая система задаёт размер foreignObject'а, точно вписывая его внутрь обводки rect'а
                * на этом её работа заканчивается
              * каким образом отображать информацию внутри заданных рамок foreignObject'а - это уже решает сам контент
          * как вписывать foreignObject в rect?
            * накладывать его точно по размеру - и тогда он будет перекрывать внутреннюю часть обводки
            * или утопить в обводку, чтобы он был точно внутри неё
            * или делать некий стандартный отступ от обводки, чтобы контент foreignObject'а не лепился вплотную к обводке
              * в итоге решил утопить контент в обводку: foreignObject.w = rect.w - stroke.w
              * это самый простой в реализации и приемлемый по внешнему виду вариант
          * как определять размер foreignObject'а и rect'а для вписываемого в них контента?
            * на данном этапе задаём размер вручную
            * попытки автоопределения размера в общем случае не работают
              * можно будет это реализовать потом, в рамках специальных редакторов для контента различных типов
          * оставить rect fill color или заменить его чем-то на основе foreignObject'а?
            * обводка всегда остаётся за svg rect'ом
            * но встаёт вопрос о том, кто будет отрисовывать внутренности knoxel'я - rect или foreignObject?
              * rect всегда будет иметь цвет, который будет определять цвет пространства
              * foreignObject может иметь цвет фона или нет, может иметь фон любого размера
                * это уже вопрос отображения конкретной информации, а не общая системная функциональность
          * реализовать базовое отображение произвольного html-контента внутри foreignObject'а для всех rect'ов
            * функция назначения контента и размера knyte'у по ghost knoxel id
              * шаблон контента для простого центрированного текста
                * <div style="display: flex; height: 100%; justify-content: center; align-items: center;">My Text</div>
              * setGhostKnуteInformationRecord - результат
            * багфикс перетаскивания ghost/bubble в случае, если space/enter был нажат над foreignObject'ом
              * сейчас их offset'ы глючат не смотря на применение pointer-events: none
            * выяснить реально ли нужен pointer-events: none для foreignObject'ов
              * на данный момент никакого смысла в этой настройке нет
              * вероятно, что-то изменится когда будет решаться вопрос с интерактивным контентом
              * а пока что мы работаем над статическим контентом с чисто информационной нагрузкой
          * как сочетать отображение foreignObject и innerspace для rect'а?
            * в итоге получается есть 2 факта совмещения: по изображению и по размеру
              * по изображению можно совмещать так, что контент foreignObject'а будет фоном для отрисовки innerspace'а
                * то есть получается слоёная структура knoxel'я: colored rect, foreignObject content, innerspace
            * по размеру foreignObject расценивается просто как ещё один вписанный в knoxel rect
              * в соответствии с его x, y, w, h он расширяет общее пространство, но не обязан занимать его целиком
    * реализация отображения контента, заданного из вне через html-код
      * включить отладочный контент, который будет работать для всех knoxel'ей
      * реализовать механизм отрисовки rect'ов с foreignObject'ами
        * на уровне вложенных rect'ов
        * на уровне space root'а
        * проверить работоспособность record view на циклических пространствах
          * обновлять space root foreignObject после каждого создания нового knoxel'я
            * в остальных ситуациях он уже обновляется сам благодаря скрытым вызовам setSpaceRootKnoxel
          * подобрать более подходящее обозначение для selfviewed knoxel
          * уточнить правило отображения контента для spacemap knoxel
            * в итоге просто решено не рисовать контент в knoxel'ях, которые отображаются иконками
            * таким образом, отрисовка контента и подпространств происходят на равных правах
        * провести рефакторинг по накопившимся проблемам
          * завязать getRootByTarget на className mouseOverRect, а не на первый попавшийся непустой id
            * потому что в произвольном контенте вполне могут быть различные id
          * в rect.add перейти от flat к type-параметру
      * контекстное редактирование контента в foreignObject'ах и назначение цвета rect'ам
        * эксперименты с редактором contentEditable на уровне произвольного хтмл-кода
          * теоретически это безграничные возможности в визуальном редактировании хтмл-вёрстки
          * на практике это очень неудобный редактор, в котором даже перевод строки в тексте - это суровая проблема
          * он не даёт ощущения контроля, все манипуляции выполняются в слепую
            * и очень сложно понять что нужно жать, чтобы получить то, что хочешь
        * принять решение о дальнейшей разработке редакторов
          * в конечном счёте редакторы должны быть реализованы через интерактивные knoxel'и
          * но пока система не достаточно развита для этого можно реализовать для развития базового функционала
            * редакторы за пределами концепции knoxel space, через классические интерфейсные элементы веба
        * редакторы information record'а на уровне простого однострочного центрированного текста
            * с автоматическим определением размера итогового rect'а
              * поразмыслив, я понял, что на ранней стадии для тестирования больше ничего не требуется
              * реализация общей системе типизации, редактирования и отображения данных пока преждевременна
            * вызывается по enter
              * для этого перевести drop/join bubble на shift+space/space
            * представляет из себя простой prompt с текстовой строкой
            * редактирует строку, которую потом прогоняет через специальный viewer
              * для оптимального отображения в виде html-объекта
            * автоопределение размера идёт по спрятанному элементу шириной во весь экран
              * решение с ограниченными возможностями, но подходящее как временное для данной упрощённой ситуации
        * редактор размера
          * вызывается по alt+enter
          * представляет из себя простой prompt с кодом вида {w: 100, h: 50}
        * редактор цвета
          * вызывается по shift+enter
          * представляет из себя простой prompt с цветом вида #ffc0ed
      * отключить отладочный контент и проверить работоспособность на произвольном контенте, создаваемом в рантайме
      * пересмотреть управление, сделать более удобным
        * по результатам обновить контролы в readme
        * оказалось удобно, когда наало и завершение определённой операции привязано к одной кнопке
          * например, Space для ghost-режима или KeyB для bubble-режима
          * а сочетания shift+space, alt+space неудобны
          * то же самое касается вызова редакторов данных/цвета/размера
      * отключение рандомного автоназначаемого цвета
        * установить цвет knoxel'я по умолчанию и дать возможность его изменять
        * подправить цветовую тему в соответствии с новым внешним видом пространства
        * сделать более удобный диалог выбора цвета с набором наглядных цветов как вариантов
      * возникнет ситуация, что пустые knoxel'и для разных knyte'ов будут выглядеть одинаково
        * потому что для только что созданного knoxel'я будет использоваться один стандартный контент
          * и разные knyte'ы могут иметь одинаковый контент
        * надо будет найти способ быстро понимать какие knoxel'и относятся к одному и тому же knyte'у
        * решение - включать bubble-режим и смотреть по обводке кто связан с текущим bubbled-knoxel'ем
          * чтобы этот режим работал во всех ситуациях, нужно selfcontained knoxel тоже делать пунктирным в bubble-режиме
            * но он всё равно будет выглядеть неуничтожаемым благодаря метке selfcontained
    * установка шрифта Menlo по умолчанию для всего веб-приложения
      * в итоге решил не подключать какие-то особые шрифты, а использовать стандартные системные
      * так как пока нет цели делать унифицированную кросс-платформенную систему
        * то пусть будет решение, которое оптимально работает на macos
        * другие платформу будем рассматривать по мере того, как они станут актуальны
  * vector
    * спроектировать как совмещать rect и arrow отрисовки в рамках одного knoxel'я
      * добавить shape для связи в rect element
      * реализовать возможность соединять стрелкой указанные knoxel'и
        * соединение через консоль через knoxelVectors
          *  knoxelVectors['']={initialKnoxelId: '', terminalKnoxelId: ''}
        * корректное поведение rect'а и arrow во всех режимах
          * точное позиционирование концов стрелки по краям initial и terminal rect'ов
            * с учётом рекурсивной вложенности пространств
          * во вложенных пространствах рисовать более тонкую стрелку - аналогично обводке
          * реализовать гениальную по своей эффективности идею со связями
            * первым делом решить проблему точного определения размеров rect'ов при подсоединении к ним стрелки
              * старый способ из spacemap через knoxelRect.getElementSize уже не прокатывает
                * потому что в момент расчёта стрелок не все элементы помещены в сцены
                * да и концептуально некоторые элементы вообще в сцене со своими идентификаторами появиться не могут
              * для активных knoxel'ей пространства
              * для рекурсивных отображений innerspace'ов
            * сделать rect соединительным joint'ом между initial и terminal частями arrow
              * и позиция этого joint'а не выставляется автоматически, а перемещается вручную
              * это радикально упрощает программинг и даёт дополнительные возможности пользователю
                * надо подправить getArrowPointsByRects и getArrowPointsByKnoxels на основании бекапов
          * следующие вопросы решаются автоматически - by design
            * как входить в подпространство стрелок
            * как вызывать редактор record'а для стрелок
            * как отображать selfcontained для стрелок
          * интерактивное создание и переназначение связей между knoxel'ями через кнопки z и x
            * модифицирует только knoxelVectors, пока что без какой-либо связи с уровнем knyte'ов
              * первая версия на стандартном ghost без частичных vector'ов (когда не все endpoint'ы определены)
              * реализация поддержки частичных vector'ов
              * разрулить ситуации частичного и полного замыкания связи на саму себя
                * когда initialKnoxelId и/или terminalKnoxelId равны jointKnoxelId
              * разрулить ситуацию, когда указанный initialKnoxelId/terminalKnoxelId не найден в текущем space'е
              * поправить определение размеров для self-connected arrows и broken arrows
                * выступающие части стрелок не учитываются в размере и в итоге могут вылазить за гарницы пространства
                  * в итоге сделал метки спец-knoxel'ей поменьше, чтобы они влазили в стандартную обводку вокруг rect'ов
              * вторая версия на специальных объектах: initial ghost, terminal ghost
                * базовый функционал
                * dotted для arrow изменяемого knoxel'я
                * selfcontained - отключить, так как связи неограниченного с ограниченным не имеют смысла
                * interspace
          * уменьшение rect'а, если у knoxel'я указаны параметры vector'а, но при этом у его knyte'а не задан record
            * 32х32 --> 10х10
          * багфикс - ошибка при divide'е knoxel'я со связями в innerspace
            * как в родном пространстве, так и в другом
              * проблема была из-за того, что во время divide knoxel'я создавался и сразу удалялся knoxel
                * для arrows которого потом на следующем кадре вызвался updateArrowShape
                  * конечно же, подходящих rectId для него в этот момент уже не существовало
              * поправлено отключением обновления пространтсва после divide knoxel
                * оно в этой ситуации не имеет никакой необходимости - как и при добавлении нового knoxel'я в space
          * придумать как интерпретировать ghost-mode для стрелок
            * в рамках host space это перемещение arrow joint'а для knoxel'я
            * в режиме interspace это перенос knoxel'я в другое пространство с обрывом связей
              * или же возврат в host space после некоторого путешествия по другим space'ам
            * во время отрисовки ghost'а должы быть видны актуальные для данного пространства связи
              * host space
              * interspace
          * придумать как интерпретировать bubble-mode для стрелок
            * пофиксить багу с тем, что divide knoxel всегда создаёт rect'ы со сплошным контуром
              * а у них должен быть пунктирный контур, так как к ним можно применить join knoxel
            * вообще игнорировать arrow для bubble-элемента
              * в том числе и не уменьшать его размер, если у active bubble knoxel'я имеются атрибуты arrow
            * проверить общее поведение во всех ситуациях
            * когда происходит join для knoxel'я, то у него могут быть связи: initials, terminals и joint
              * по базовой концепции объединения пузырьков в результате join'а внешние связи не должны исчезать
                * но если сам knoxel является связью, то эта связь должна исчезнуть
              * в итоге получаем такие требования к функционалу
                * связь joint knoxel'я должна исчезать после join'а и удаляться из knoxelVectors
                * initials и terminals связи joint knoxel'я должен принимать на себя bubbled knoxel
                  * чтобы не происходило обрывов связей
    * спроектировать vector'ы между knyte'ами
      * команда соединания knyte'ов vector'ом
      * наложение ограничений на соединение knoxel'ей vector'ами с учётом структуры knyteVectors
      * реализовать все вариации knoxel vector'ов на уровне интерфейса в соединении с knyte'ами
        * привязка knyte vector'ов к initial ghost, terminal ghost
        * режимы initial bubble, terminal bubble на кнопках KeyN, KeyM соответственно
          * базовый режим
          * setArrowBubbledMode
        * привязка knyte vector'ов к initial bubble, terminal bubble
        * разрулить нажатие KeyN/KeyM на неподходящем knoxel'е
          * должно быть такое же поведение, как при нажатии на пустом месте - аналогично KeyB
    * подумать что делать со связями и особыми стрелками в spacemap-knoxel'е
      * в принципе связи в spacemap выглядят и работают нормально, может быть даже для чего-то пригодятся
        * но смущает, что стрелки связей очень похожи на стрелки вложенности в пространства
      * надо придумать как визуально различать разные типы стрелок без ухудшения читаемости схемы
        * делаем просто другую форму маркеров у стрелок - этого будет достаточно на первое время
    * подумать что делать с изменением color, size, record для spacemap-knoxel'я
      * color можно менять вне зависимости от цвета spacemap-кнопки, который остаётся фиксированным
        * также надо привести форму кнопки spacemap в соответствие с формами других кнопок - сделать обводку
      * багфикс - при смене цвета knoxel'я нужно менять и цвета связанных с ним кнопок spaceBack/spaceForward
      * игнорировать size и record для spacemap
        * то есть туда можно записать какую-то инфу, как и в любой knoxel, но ничего из этого не будет показано
  * и всё вместе в любой комбинации
    * разделить size на 2 части:
      * record size задаётся для всего knyte'а, действует во всех пространствах
        * прописывается в record.size = {w, h}
        * определяет размер зафиксированного в {x: 0, y: 0} foreignObject'а для отображения record'а
          * как в режиме space, так и для recursive
      * knoxel collapse задаётся для конкретного knoxel'я и действует только в его host-пространстве
        * определяет показывать innerspace knoxel'я или схлопнуть его до размера иконки
        * определяется в knoxelViews[knoxelId].collapse
          * после интенсивных размышлений пришёл к выводу, что кастомный размер knoxel'я не имеет большого смысла
            * потому что в большинстве случаев нужно просто целиком его схлопнуть до минимальных размеров
              * при этом для кастомных размеров rect'а требуется clipping контента, который неоправданно сложен в разработке
    * реализовать назначение разных цветов стрелкам и обводке rect'ов
      * цвета могут быть 2 типов: цвет knyte'а и цвет knoxel'я
        * цвет knyte'а задаёт цвет фона, на котором рисуются record и innerspace
        * цвет knoxel'я задаёт цвет обводки rect'а и arrow
          * определяется в knoxelViews[knoxelId].color
    * ряд багфиксов и мелких правок
      * на уровне редактора вернуть центрирование текста по knoxel'ю для oneliner'ов
      * объединить visualTheme rect.recursive.strokeWidth и arrow.recursive.strokeWidth в recursive.strokeWidth
      * объединить visualTheme rect.strokeColor и arrow.strokeColor в knoxel.defaultColor
      * убрать отрисовку стрелки, когда нет связи
        * необходимо для корректной отрисовки ректов с прозрачным фоном
      * багфикс для пары особых кейсов отображения arrow
      * более логичное отображение для оборванных связей
    * багфикс - поправить разные смещения foreignObject'ов в разных пространствах
      * spaceroot, 1st level innerspace, 2+ level innerspace
      * смещения различаются на порядок толщины обводки, где-то она некорректно прибавляется/вычитается
        * после долгих размышлений решено переделать принцип позиционирования и выравнивания foreignObject'ов
          * теперь они не будут учитывать толщину обводки и будут рисоваться относительно базового размера и положения rect'а
            * то есть код типа x -= strokeWidth/2 и w -= strokeWidth для foreignObject'ов больше не понадобится
    * багфикс - после правки по foreignObject'ам размер oneliner'ов стал слишком маленький и на них наезжает обводка rect'ов
      * решение в том, чтобы на уровне редактора всем давать фиксированный отступ равный, например, visualTheme.rect.strokeWidth
    * составить список майлстоунов и внерить их в roadmap
      * чтобы было понятно какой функционал к каким этапам внедрения будет нужен
* реализовать интерактивное поведение knoxel'ей
  * редактор для написания многострочного форматированного через \t и \n текста
    * который можно интерпретировать в интерактивных блоках как код для выполнения
    * этапы реализации
      * универсальный диалог редактирования с выбором типа контента
      * к oneliner добавить форматированный текст
      * назначение и изменение форматированного текста в knyte.record'ах
      * довести удобство использования редактора до приемлемого уровня
  * редактор для написания html-кода для вставки в foreignObject'ы
    * тип будет называться interactive
  * модуль запуска кода из knyte.record'ов
    * желательно в отдельном потоке, чтобы это не стопорило навигацию в основном потоке
    * общая реализация
      * интерактивная кнопка для запуска вычислений
      * подключение блоков-параметров с кодом для запуска
      * запуск подключенного кода самым простым способом
        * без обработки ошибок - для ситуации, когда всё работает
          * с отображением статуса интерактивного блока (ready/working) и последнего вычисления (none/success/failed)
        * с обработкой ошибок транслирования и рантайма
      * добавление входящих параметров
      * добавление выходящих параметров
  * линейная связка интерактивных блоков, которые выполняются один за другим автоматически
    * упрощённый прототип перехода на knoxel-based run block'ах
  * оформить промежуточную спецификацию на run block'и
    * она же - тесты на правильность поведения системы
      * сохранение/загрузка состояния системы
        * начать функционал сериализации состояния апа
        * решить проблему с record.viewer - это должна быть строка, а не функция
          * унифицировал названия типов viewer'ов и перевёл всё на них
        * встроить загрузку в интерфейс аппа
          * желательно повесить на drag'n'drop файла на окно приложения
        * встроить сохранение в интерфейс аппа
          * желательно повесить на cmd+s или отдельную кнопку в интерфейсе
        * описать в readme операции для сохранения/загрузки состояния системы
          * соответственно cmd+s и drag'n'drop файла
      * одиночный run block
        * штатная работа
        * все возможные баги
      * цепочка run block через next'ы
        * штатная работа
        * все возможные баги
      * проблематика knoxel-based и knyte-based реализации run block'ов
  * перевод run block'ов на knyte-based
    * все изменения состояния knyte'а синхронизируются между всеми его knoxel'ями
    * состояния knoxel'ей не сбрасываютсяпри обновлении пространства
    * код запускается не из визуального блока knoxel.foreignObject, а из единого knyte-центра
      * доступность которого не зависит от видимости knoxel'ей из текущего space root'а
    * реализация
      * синхронизация контента видимых блоков и active rect'ов
      * тест-кейс про продолжение выполнения цепочки команд после фейла одной из них
        * с параметрами, идущими по цепочке вместе с блоками
      * единый центр запуска для видимых и невидимых блоков
        * запускать код по next не через knoxel, а через knyte
          * главный эффект выражается в том, что если next переходит на невидимый knoxel, то его knyte всё равно запускается
        * не создавать каждый раз для запуска кода новую виртуальную машину без надобности
          * сейчас на каждый запуск любого кодового блока создаётся новая VM
          * а по хорошему у каждого run block'а должна быть своя VM, которая пересоздаётся только при изменении кода и параметров
          * при этом старые VM должны сохраняться на случай, если run block'у вернут предыдущий код и параметры
  * багфиксы по интерфейсу run block'ов
    * если у run block'а есть output parameter'ы, то после выполнения у него не отображается success
      * потому что сразу после назначения success происходит перестраивание всего пространства
        * чтобы отразить изменения во всех output parameter'ах
    * если во время выполнения кода вызвать обновление пространства, то его статус сбросится
      * например, если что-то передвинуть
        * это вызвано тем, что визуальный элемент run block'а пересоздаётся, а его статусы хранятся только внутри него
    * баги пофиксились автоматически благодаря переходу на knyte-base run block engine
  * спецификации на input и output параметры
  * оптимизация диффов в гите
    * реализовать сортировку ключей внутри json-файла со стейтом системы через JSON.stringify replacer as an array
      * как оказалось он не только содержит набор разрешённых для сериализации полей, но и задаёт глобальный порядок их сортировки
  * условные переходы между связками
    * прототип if then else
    * прототипы while и/или for
      * если в них есть смысл при наличии if then else
        * после изучения вопроса оказалось, что имея прямой доступ к потоку управления, нет нужды в операторах цикла
        * достаточно иметь мощные операторы переключения потока
      * в итоге решил совместить возможности классических if и switch в оригинальной flow-oriented реализации if
    * прототип if case else
  * оформить общую концепцию
    * фокуса ввода
      * пока что из интерактива реализованы только кнопки в html-блоках
        * для них действует правило, что фокус (tabstop, tabindex) на них не задерживается
          * но нажать на них можно вне зависимости от уровня вложенности
      * поведение остальных интерактивных элементов будет стандартизироваться по ходу разработки
        * и походу необходимости их использования для реальных задач
    * изменение из кода на уровне knyte.record.data
      * по факту все изменения, которые сейчас возможны в run block'е, происходят на уровне knyte.record.data
        * поэтому в частности не возможна реализация array, hashmap, run block as parameter
      * на данном этапе система находится на уровне ZX Spectrum Basic с чисто скалярными типами данных
        * дальнейший прогресс возможен путём добавления рекурсии параметров run block'ов
          * и управления knyte'ами и knoxel'ями из кода run block'ов
    * синхронный запуск для run block code
      * код run block'а хоть и запускается через setTimeout, но не использует async и другой поток
      * то есть он не блокирует выполнение основной логики, но не имеет ряда фичей (await) и устойчивости к зависаниям
    * интерактивные события и обработчики событий
      * пока что нет общего подхода к решению этой задачи, потому что она ещё не настолько актуальна и оформлена
        * для текущих задач кнопки run реализовано кастомное решение на уровне системы
    * убрать обязательную задержку при запуске run block'ов
      * но при этом надо понять как реализовать интерактивное отслеживание выполнения программ
        * и как решать проблемы слишком долгих кодовых блоков
      * решение
        * добавить тест-кейс с долгим выполнением кода
          * показать в нём, что при синхронном однопоточном запуске вся система фризится на время выполнения кода
            * выходом из этой ситуации будут асинхронность и/или многопоточность (скорее всего через web worker'ы)
              * было бы круто привязать управление асинхронностью и многопоточностью к структуре графа
        * управлять задержкой выполнения run block'ов через единую глобальную переменную в консоли
          * описать этот метод в readme
          * по умолчанию задержка равна 0
            * из-за setTimeout код будет выполняться не сразу, а в следующем цикле отрисовки браузера
    * багфикс: нужно сбрасывать ok-стейт с run block'а если у него меняются параметры или код
      * иначе ok как метка проверки корректной работы run block'а становится неактуальной
        * или же надо придумать другой флоу для стейтов ok/failed
      * в итоге я просто решил отказаться от ok-стейта
        * реальный смысл есть только в busy- и failed-стейтах
          * и их реализация не вызывает особых трудностей или переусложнения системы
    * багфикс: в некоторых ситуациях после ошибки в коде next идёт дальше
    * добавить статус выполнения кода, чтобы понимать состяние системы и принимать решения на основе него
    * решить что делать с сохранением стейта системы во время выполнения кода
      * на начальном этапе запрещаем сохранение во время выполнения программ
        * это гораздо проще, чем разруливать различные гипотетические ситуации,
        * которые не имеют высокой ценности для первого майлстоуна
    * багфикс: если перед загрузкой стейта будет выполняться код, то после загрузки он так и будет выполняться
      * то есть при сбросе стейта системы не происходит сброс выполнения кода. а должно бы.
        * запрещаем загрузку, если в системе выполняется код
* МАЙЛСТОУН-1: обучающий фреймворк по императивному программированию
  * knoxelSpace как базовая структура для решения задач интерактивного программирования
    * вместо традиционной текстово-файловой структуры
    * оперируя простыми типами: строка, число, булево значение
    * без рекурсии в параметрах - то есть когда нельзя в run block передавать параметром другой run block
  * адаптация readme под быстрый старт изучения системы
  * видео с мотивацией - зачем изучать knoxelSpace и использовать его в повседневной работе
  * видео с наглядным описанием работы интерфейса
* расширение интерактивного функционала
  * решение вопросов перегрузки knoxel'ей информацией
    * что делать со слишком большим контентом, который нет необходимости показывать целиком?
    * что делать, если не нужно показывать 
      * контент
      * innerspace
      * и контент, и innerspace
    * текущим решением для всех этих вопросов является функционал collapse/expand по KeyD
  * создать девелоперскую копию space в space-dev, чтобы не ломать функционал пользователям системы
  * поддержка управления на винде
    * cmd --> ctrl
  * асинхронный запуск для run block code
    * в частности чтобы делать await fetch
      * пример использования для получения данных по GET через какой-либо piblic API
    * пример постановки задачи в knyte id 566be9ba-5a43-4865-b44d-2d2fd0b05f48
    * системное решение для асинхронных вызовов
      * через async/await на уровне блока code, чтобы сохранить линейный синхронный стиль
    * привести в порядок тест-кейс по await
  * поддержка управления на линуксе
    * cmd --> ctrl
      * по факту сейчас на любой os, кроме macos, кнопка cmd (meta) заменяется на ctrl
  * строгая типизация для параметров
    * указывается в описании параметров run block'а в виде
      * (a:number)
      * (b:json)
    * спецификация
      * Array и Object через :json
      * Number через :number
      * String по умолчанию
    * для if-case обработка значений =xxx не изменится и не будет зависеть от их типа
    * реализация
      * базовая система
      * базовые тест-кейсы под типизацию
      * обновление старых тест-кейсов для работы с типизацией
      * релиз
  * добавить shortcut для создания run block'а
    * cmd+alt+click
  * адаптация управления под browser built in zoom-in/zoom-out by commands/touchpad
  * пространственная навигация по пространствам knoxel'ей
    * сюда же входит масштабирование и позиционирование содержимого knoxel'ей
    * по сути это концепция "широкого пространства"
    * реализация
      * отключить встроенные в браузер возможности масштабирования
        * чтобы избежать конфликтов функциональности и багов
          * после краткого изучения вопроса оказалось, что нет нормального способа это сделать
          * получается, пользователи самостоятельно должны избегать использования этих функций
      * перемещение по пространству через vertical/horisontal scroll
        * ядро перемещения
        * корректная работа стандартных функций в перемещённом пространстве
          * основная масса функций
          * когда начинаешь рисовать стрелку, а потом двигаешь пространство
          * когда перемещаешь стрелку через ghost
      * масштабирование пространства через shift + vertical scroll
        * заложить базу функционала
        * центрировать zoom на точке курсора при любом pan
        * стабилизировать поведение при увеличении/уменьшении масштаба
        * пофиксить вычисление позиций для концов стрелок
          * для основных стрелок
          * для ghost arrow
          * для стрелок во внутренних пространствах
      * пройтись по всем функциям из readme и проверить корректность их работы
        * готово, найдены кое-какие некритичные баги
      * описать в readme новое поведение steering
      * поправить найденные баги
        * при добавлении knoxel'я в пространство его размер неоправданно раздувается
          * потому что опимизатор размера пространства не срабатывает
          * когда knyte'у раньше было назначено какое-либо значение
            * потому что в informationMap для этого knyte'а уже есть record.size
          * решение - при назначении пустой data удалять record.size
        * если в процессе z/x/n/m перейти в другое пространство, то превьюшка ломается
          * затем её можно восстановить движением курсора, но раньше такого не было
            * проблема была в лишнем переводе координат при пересоздании active arrow
        * сохранять масштаб knoxel'я в превью режимов ghost и bubble
          * спецификация
            * при создании active rect'а он должен быть такого же размера, как и его прородитель
            * при изменении масштаба пространства размер active rect'а не изменяется
            * при помещении active rect'а в пространство результирующий knoxel должен иметь такой же размер в screenspace'е
          * таким образом мы реализуем удобный инструмент масштабирования элементов
            * не требующий дополнительных интерфейсов
          * реализация
            * применение масштаба к active rect
              * общий функционал
              * корректная работа offset'а
              * корректная работа selfcontained
              * корректное отображение ghost arrow
                * zoom
                * offset
                * steering update while ghosting 
                  * pan
                  * zoom
                  * cross ghost arrow offset
        * выдать дев-версию на ревью и тестирование
        * спроектировать поведение масштабов и сдвигов в пространствах при переходах между ними
          * сейчас действует одно и то же смещение на всех и ощущается это хаотичненько
          * спецификация
            * при входе в пространство
              * все его элементы сохраняют свои положения и размеры в screenspace'е
              * просто исчезают границы и все элементы из других пространств
            * при выходе из пространства (возврат к предыдущему)
              * все его элементы сохраняют свои положения и размеры в screenspace'е
              * просто добавляются границы и окружающие элементы хост-пространства
          * реализация
            * инициализация во время загрузки спейса из файла
            * rect click
              * data case
              * innerspace case
              * mixed case
              * selfcontained
            * space back
              * knoxel transition case
              * selfcontained transition case
              * knoxel replaced case
            * space forward
              * knoxel transition case
              * selfcontained transition case
              * knoxel replaced case
            * spacemap
              * assign (0,0) offset in the spacemap
            * space host
              * center ghosting knoxel in the space host
                * в итоге я решил вообще удалить этот функционал как невостребованный
            * придумать что делать, если размер target-пространства knoxel'я меняется при переходе
              * сейчас сохраняется положение верхнего левого угла knoxel'я
                * а я бы хотел сохранять положение его центра
              * повесить шорткаты на кнопки spaceBack, spaceForward
                * кнопки стрелка вниз и вверх соответственно
              * кейсы для рассмотрения
                * rect click
                * space back
                * space forward
            * отладка редких и сложных кейсов
              * особое внимание уделить перемещению knoxel'ей между пространствами
                * ситуациям когда опорные knoxel'и в пространствах не найдены
              * оттестировать поведение selfcontained knoxel'ей при переходах
        * отрелизить готовый steering на новом хостинге
          * новый эталон - repl.it
          * подцепить к рутовому домену knyte.io
          * подправить ссылки на артефакты проекта в readme
          * закрыть все ссылки на glitch.com
        * пересмотреть весь план исходя из кратчайшего пути достажения главной цели
          * релиз минималистичного фреймворка по логическому программированию
            * для ускорения релиза можно отложить задачи
              * масштабирование knoxel'ей - это некритично сейчас
              * множественное выделение - его можно заменить scope'ами
              * серверное выполнение кода - убирать дублирование сущностей тоже пока некритично
  * рефакторинг: вынести steeringElement в глобальные переменные
  * оформить спецификацию на scope
    * чтобы не забыть на будущее
  * протянуть сайт на домен knyte.io
    * http://knyte.io/
    * https://knyte.io/
    * http://www.knyte.io/
    * https://www.knyte.io/
  * концепция логических операторов and/or/not для потоков данных
    * скорее всего здесь придётся реализовать концепцию потоков данных
      * а не потоков управления как в обобщённом программировании
        * где стрелки передают от блока к блоку управление, но не данные
    * смоделировать пример задачи для решения: структуры входящих и исходящих данных и цель их преобразования
    * реализовать обобщённые логический модуль, который работает с такого рода структурами
    * написать базовый набор тест-кейсов, которые проверяют работоспособность простых операторов
      * и демонстрируют способы их использования
  * реализовать серверный вызов run block'ов через api
    * создать хостинг на https://knyte.herokuapp.com/ и http://api.knyte.io/
    * написать простой сервачок
    * написать серверную версию движка run block'ов
    * оформить тест-кейс для публичных api-вызовов с параметрами в адресной строке
    * обеспечить возможность простой авторизации и передачи параметров в функции
      * через поля header'а в get-запросе
      * через body в post-запросе
        * при этом писать содержимое body в параметр-knyte'е body:json, а результат направляется в result:json
  * рефакторинг: перейти на stage и prod разработку без копий кода в space/space-dev
    * использовать вместо этого бранчи гита и возможности автоматического деплоя netlify/heroku
      * на публичный домен knyte.io в итоге будут попадать только prod-релизы
    * удалить space-dev
    * наладить dev-бранч на glitch'е
    * рефакторинг: унифицировать вызовы steeringElement.getCTM()
      * делать поиск по всем steeringElement, так как не везде идёт прямой вызов
    * наладить dev-хостинги на netlify
      * dev-хостинг сервера на heroku пока не требуется
        * но может будет создан по необходимости
  * адаптировать api тест-кейсы под запуск как на сервере, так и на клиенте
  * написать полный набор тест-кейсов для логических операторов
    * которые проверяют работоспособность logic-блоков во всех ситуациях
      * и демонстрируют способы их использования
    * построить домен, описать факт и набросать общее правило принятия решений по ним
    * сделать общее правило достаточно интересным и многоуровневым, чтобы показать всю комбинаторику
* МАЙЛСТОУН-1.5: тестовый фреймворк по логическому программированию
  * когда потоки булевых значений true/false проходят через логические операторы and/or/not
* расширение функционала под релиз системы прототипирования модулей
  * подключить универсальное хранение app state'ов для клиента и сервера
    * по результатам исследования решено сделать это на gist'е от github
    * клиентская часть
      * страница /space/connect для конфигурирования подключения через localStorage
        * чтобы не протаскивать в url'е секретные данные
        * по умолчанию будет пустое пространство
      * автозагрузка knoxelSpace.json и подключенного gist'а
      * сохранение knoxelSpace.json в подключенный gist
    * серверная часть
      * перенос core knoxelSpace.json из git-репозитория в gist
      * подключение к соответствующим gist'ам при запросах с клиентов
        * то есть по умолчанию у сервера нет никакого сохранённого app state'а
    * репрезентативный тест-кейс
      * написать api call для расчёта корней квадратного уравнения по заданным на клиенте коэффициентам a, b, c
        * a * x ** 2 + b * x + c = 0
    * пофиксить критичное падение сервера на Heroku
      * удалось смоделировать ситуацию, когда 1 вызов апи ломает весь сервер так, что помогает только manual deploy
        * чтобы сломать сервер нужно вызвать апи-метод с некорректным root knyte id
          * нужно указать knyte id run block'а, который не является root'ом корректно оформленного api call'а
            * то есть не имеет параметров body и result
      * вариант решения - перейти с облачного сервера Heroky на атомарные Netlify Functions
        * есть гипотеза, что они более устойчивы даже к таким критичным поломкам
        * при реальной проверке выяснилось, что благодаря отсутствию стейтов лямбда-функции работают более надёжно
          * в реальной разработке очень сложно следить за корректностью стейта приложения
            * но если он ломается, то могут сломаться все последующие вызовы API-методов
              * и потребуется ручной перезапуск сервера или написание и запуск watch dog'а
          * при этом польза от стейтов при реализации концепции knyte'ов только в несущественной оптимизации времени вызова
            * надёжность и простота кода является более приоритетной
        * перевести core knyte appstate с Heroku App на Netlify Functions
      * добавить netlify.toml с указанием Functions directory, чтобы не настраивать аппы в ручную на этапе создания
  * наладить ssl для апи-коллов
    * до перехода на netlify functions работало только на http://api.knyte.io/
      * сервер хостился на Heroku, и подружить его с ssl на кастомном домене можно было только на платном тарифе
    * решение задачи и упрощения инфраструктуры
      * исследовать возможность и оправданность миграции хостинга для сервера
        * с Node.js Heroku app на Netlify Functions
          * принципиально получилось выполнить миграцию
          * при этом пришлось скопипаситть server.js и внести в него правки относительно fetch и пары других особенностей
          * выявилась потенциальная проблема с ограничением числа запросов к АПИ без авторизации (60 шт/час)
            * решение - всегда делать авторизованные вызовы, PAT передавать через клиентский body
              * чтобы не хранить на сервере собственный PAT, а распределять нагрузку по вызовам на пользователей
      * перенести сервер с Heroku на Netlify Functions
        * пока что только на уровне использования, код для Heroku пусть пока остаётся
        * новый url для апи-коллов: https://knyte.io/.netlify/functions/runblock
  * добавить возможность добавлять knyte'ы с заранее заданными идентификаторами
    * требуется для переноса семантики между базами знаний
* МАЙЛСТОУН-2: схематичное моделирование и прототипирование отдельных модулей реальных приложений
* работа с группами knoxel'ей
  * функционал полноценного множественного выделения весьма трудозатратен и сложен с точки зрения дизайна
    * поэтому попробуем добиться основных эффектов с помощью пары продвинутых функций манипулирования пространствами
  * спецификация
    * перенос knoxel'ей, выбранных прямоугольной рамкой, внутрь вновь созданного knoxel'я
      * с сохранением их относительных позиций
        * режим стартует по alt+shift+click
        * в поцесе отображается полупрозрачная рамка и полноцветные обводки накрываемых ею knoxel'ей
        * режим заканчивается по click или отменяется по esc
    * перенос knoxel'ей из выбранного knoxel'я в space root (extract)
      * действие, обратное объединению knoxel'ей рамкой
        * инициируется через KeyE и требует подтверждения prompt'а - аналогично collapse/expand'у для knoxel'я
        * knoxel, из пространства которого вынули все вложенные knoxel'и, размещается в позиции курсора мыши
          * на момент вызова функции по нажатию соответствующей кнопки
  * реализация
    * `вынесение knoxel'ей из выбранного knoxel'я в space root`
    * упаковка knoxel'ей накрываемых рамкой в новый knoxel
* gist ux
  * обязательная сквозная авторизация в gist через сервер, чтобы не упираться в анонимные лимиты апи коллов
    * 60 вызовов в час без авторизации на весь сервак против 5000 вызовов в час с авторизацией на каждого клиента
    * соответственно можно будет убрать process.env.githubPAT из приложения Netlify
  * ограничение на объём загрузки - 12 Мб
    * чтобы не грузили в gist слишком большие файлы и не забывали про очистку кешированных файлов
  * оптимальная обработка перезагрузки
    * например, если перейти из master knoxel в более глубокие слои, сохраниться там, потом совершить ошибку
      * появится желание перезагрузиться и начать всё заново
        * но после перезагрузки выкидывает на master knoxel
          * придётся опять искать целевой knoxel, чтобы продолжить текущую работу
    * это сильно отвлекает, делает процесс работы прерывистым
      * поэтому надо разрулить как сохранять актуальный root knoxel и не терять доступ из него к master knoxel'ю
  * когда gist загружен без write-доступа, делать его автоматически readonly
    * простой плашки gist is readonly в верхнем правом углу будет достаточно
  * предотвращать перезапись gist'ов с потерей данных из разных инстансов knoxel space'а
    * при загрузке gist'а сохранять загруженную ревизию
    * перед сохранением gist'а проверять, что последняя ревизия равна загруженной
      * если это не так, то предупреждать пользователя что появилась новая ревизия/несколько ревизий файла
        * и есть риск потерять данные из них, если продолжить сохранение
      * при этом нет смысла запрещать сохраняться - пусть пользователь сам решает
* визуальное представление структур данных
  * на данный момент структурные данные (arrays, objects/dictionaries) представляются как json
    * это ненаглядно и ломает основную концепцию семантической сети, вводя в пайплайн парсинг
  * плюс json-структуры вызывают непонимание со стороны студентов
    * которые не имеют достаточно опыта, чтобы их бегло читать и правильно понимать
  * решение - реализация собственных семантических структур для описания сложных данных
    * словарь простых элементов (string, number, bool)
    * массив простых элементов (string, number, bool)
    * рекурсивный объект
      * словарь/массив из простых элементов, словарей, массивов и рекурсивных объектов
* устранение копипаста в коде
  * на данный момент запуск run block'ов реализован в 3 вариациях:
    * клиентская (браузер)
    * heroku
    * netlify functions
  * нужно создать универсальную реализацию, которая будет работать как для браузера, так и для netlify functions
    * при этом все старые реализации нужно удалить, поддержку деплоя на heroku нужно прекратить
* преобразование spacemap из тормозящего хлама в удобный инструмент навигации по несвязным островам knoxel'ей
  * нужна оптимизация - чтобы не пересобирать всё пространство spacemap по каждом малейшему изменению
    * есть предположение что именно из-за этого очень долго выполняются простые циклы, реализованные на run block'ах
  * нужен полный редизайн фичи
    * как минимум, в карте пространств нужно отображать только представителей отдельных островов, а не все knyte'ы cloud'а
* сделать альтернативное управление steering'ом для Windows и Linux
  * так как на них обычно нет удобного тачпада и нужно справляться мышью
* МАЙЛСТОУН-3: наглядная визуальная разработка комплексных приложений для реальных бизнес-задач
* перевести хранение персистентных данных с gist на git repos
  * цель данной реализации
    * снятие ограничений на размеры файлов в gist'е
    * хранение knyte appstate'а в одном репе с клиентской частью и лямбда-функциями
    * деплой knyte appstate'а в комплекте с кодом лямбда-функции для его локальной подгрузки
      * это существенно ускорит время выполнения функции и повысит надёжность её работы
* сохранять масштаб knoxel'я в превью для режимов ghost и bubble
  * реализация - вторая очередь
    * механизм назначение масштаба knoxel'ям
    * задание масштаба knoxel'я из active rect'а в момент его перемещения (ghost) или создания (bubble)
  * реализация - третья очередь
    * через alt + vertical scroll масштабировать active rect
      * чтобы вставлять его в новом размере в фиксированное по масштабу хост-пространство
    * не является необходимостью, а скорее удобство интерфейса
* scope'ы для run block'ов
  * возможность подсоединить к run block'у аналогично code или if новый параметр scope
    * он должен содержать в своём пространстве последовательность run block'ов
      * также метки начала и окончания выполнения
        * когда родительский run block стартует, управление передаётся на метку начала scope'а
        * когда управление доходит до метки окончания scope'а родительский run block считается выполненным
          * и передаёт управление дальше по next'у следующим run block'ам
  * данный функционал подобен функциям C или подпрограммам Basic
    * для наглядной спецификации смотреть раздел scopes в run blocks specification
* видимость переменных внутри scope'а
  * все входящие и исходящшие переменные, прикреплённые к родительскому run block'у, доступны во всех run block'ах скоупа
  * на старте scope'а все исходящие переменные, вложенные в него, инициализируются пустыми строками
* нелинейные конструкции связок
  * когда сразу несколько выполнявшихся параллельно потоков сходятся к одному элементу
    * этот блок схождения можно назвать аккумулятором потоков управления
    * прежде чем переходить дальше аккумулятор должен дождаться окончания выполнения всех входящих в него потоков
      * для обеспечения многократных запусков аккумуляторы должны быть помещены в scope'ы
        * и автоматически инициализироваться при каждом запуске скоупа
          * иначе в них будет накапливаться старая информация и они будут неправильно срабатывать
  * когда из одного элемента выходят сразу несколько потоков, выполняющихся параллельно
    * разрешить выход нескольких next'ов из одного run block'а и посмотреть к чему это приведёт
* реализовать все необходимые модули спецификации и примеры использования силами студентов
  * полный набор тест-кейсов для типизированных параметров
  * реализации классических циклов и условных переходов
  * рассчёт числа Пи с высокой точностью без входящих и выходящих параметров
    * базовая реализация без внешних параметров
    * в отдельном потоке, чтобы не блокировать интерфейс долгими вычислениями
      * и желательно не иметь доступа к полному контексту системы (DOM, global js runtime, etc.)
    * входящий параметр - количество итераций для вычислений
    * выходящий параметр - результат вычислений
  * рассчёт другого трансцендентного числа с высокой точностью
* дополнительные интерактивные knyte'ы
  * по аналогии со spacemap нужно сделать vectormap для отражения всех связей выбранного knyte'а
  * может быть аналогичную вещь надо будет сделать и для knoxel'ей
    * без такой функциональности сложно следить что происходит со связями
  * модули jumpknoxel, jumpknyte для телепортирования к указанным элементам по id
  * модуль searchdata для поиска knyte'ов по record.data
  * подумать есть ли возможность реализовать vectormap, spacemap и searchdata на интерактивных knoxel'ях
  * реализовать редакторы не только для oneliner'ов, но и для многострочного форматированного текста, для кода (html/js)
    * показывать код в knoxel'ях как в текстовом виде с подсветкой, так и в виде интерактивного html
  * подумать как заменить кнопки spacemap/spaceback/spaceforward/spacehost на стандартные интерактивные knoxel'и
  * реализовать для KeyV нормальный диалог выбора цвета, как и для KeyC
  * разделить стандартные цвета между KeyC и KeyV
    * в KeyC будут те цвета, которые подходят для фонов rect'ов
    * в KeyV будут те цвета, которые подходят для обводок rect'ов и arrow
      * соответственно любой цвет из KeyV должен хорошо читаться на любом цвете из KeyC
* плановый рефакторинг
  * выстроить более простую, понятную и унифицированную логику в knoxelRect.add
    * заодно избавиться от дублирования кода между createShapes, createFigure, knoxelSpaceRoot.update
  * выделить всю логику из обработчиков вида function onXXX в отдельные функции
  * каким-то образом обобщить очень сходный код для activeGhost/Bubble, activeInitial/TerminalGhost/Bubble
  * при изменении knoxel.color перекрашивать не только обводку rect'а и линию arrow, но и маркеры на концах arrow
  * объединить knoxels, knoxelVectors и knoxelViews в knoxelSpace со следующей структурой
    * knoxelSpace[knoxelId] = {knyteId, vector: {initialKnoxelId, terminalKnoxelId}, collapse, color}
  * переименовать knyteVectors в knyteCloud
* расширение интерактивного функционала
  * рассмотреть возможность реализовации передачи в run block параметром другого run block'а
    * с последующим вызовом
      * как аналог подпрограмм в ZX Spectrum Basic или вызова функций в C
      * или другими словами - метод повторного использования кода
  * изменение из кода на уровне knyte
  * изменение из кода на уровне knoxel
* компиляция run block next-chain в единый run block code
  * по идее это должно резко сократить накладные расходы на визуализацию и блочно-ассоциативную структуру алгоритмов
    * когда функционал спроектирован, написан, отлажен и про его модификацию можно забыть,
    * то его вполне можно скомпилировать в единый блок и запускать на высокой скорости из других модулей системы,
    * не вдаваясь в детали реализации и поведения в рантайме
* МАЙЛСТОУН-4: рефлексия на уровне истории изменений и реализации прикладных функций
* хранение в системе всей истории изменений
* отображение диффов между любыми точками из истории изменений для любых групп knyte'ов и knoxel'ей
* хранение всей функциональности системы исключительно в структуре knyte'ов
  * без необходимости использовать средства javascript для описания дополнительных характеристик объектов
* реализация всех функций системы, для которых это в принципе возможно, через возможности самой системы
  * не прибегая к внешним надстройкам за пределами
    * knyteCloud на уровне хранения данных
    * knoxelSpace на уровне интерактивного интерфейса
  * найти способ оформить кнопки spaceBack, spaceForward, spaceHost как интерактивные knoxel'и
  * найти способ унифицировать поведение knoxel'я space map со всеми остальными knoxel'ями
    * и оформить его кнопку как интерактивный knoxel
* МАЙЛСТОУН-5: исследование концепции интерактивной базы знаний и семантического языка программирования