План работы
-----------
* перечитать и обновить тексты
  * уйти от терминов операционной системы и языка программирования
  * оформить ревизию 2
  * залить изменения
* перечитать все формулировки и сделать ревизию 3
  * особое внимание - на мотивацию и цель
  * подтвердить целостность технической терминологии
  * залить изменения
* начать dom+svg реализацию knoxel space в новых терминах
  * но по мотивам старого плана, который достался от WebGL/ThreeJS-версии
  * так как я пришёл к выводу, что ускорение отрисовки сейчас не главное
* вынести план работ в отдельный файл
* создание knoxel'ей в space по клику
* применение описательной схемы для определения вида элементов и пространства
* автоматическое растягивание visualRoot на полный экран
* knoxel space как содержимое knoxel'я
  * создавать идентифицируемые rect'ы рандомного цвета при фиксированном цвете обводки
  * выбирать тот rect, который станет активным спейсом и развернётся на весь экран
    * по клику
    * через консольную команду по id rect'а
  * в runtime хранить в каждом rect'е его собственное подпространство
    * тогда через консоль можно будет произвольно путешествовать по всем созданным в runtime rect'ам
  * стартовать с пары смотрящих друг на друга knoxel'ей
  * при входе внутрь пространства knoxel'я автоматически создавать обратную связь
    * чтобы все пространства были визуально связаны между собой и нельзя было бы попасть в тупик
  * придумать как перемещаться между rect'ами через визуальный интерфейс
    * обходиться для навигации без консольных команд и знания обо всех id rect'ов
      * по факту автоматическая связность пространств позволяет осуществлять необходимую навигацию
* ввести knyte'ы как источники knoxel'ей
  * knyte обладает цветом фона в качестве information record'а
  * определение knyte'ов через knit'ы
  * рефакторинг knit'а как singleton и параметров функций addKnoxel, addRect, restoreRect
  * создание как новых knyte'ов, так и дополнительных knoxel'ей для существующих knyte'ов
    * cmd+click - новый knyte и knoxel для него
    * alt+click на knoxel'е - новый новый для его knyte'а
    * alt+click на root space'е - новый новый для knyte'а root space'а
  * привязка space'ов к knyte'ам вместо knoxel'ей
  * рефакторинг - во всех переменных типа rootId указывать что это за id: knyte/knoxel/element/etc.
  * быстрая реализация кнопки "назад" для навигации по пространствам
  * решить вопрос с неконтролируемым и потенциально бесконечным заползанием внутрь одного и того же knoxel'я
    * происходит, если кликать на его rect по многу раз
  * рефакторинг onLoadBody -> rootKnyteId/rootKnoxelId/rootColor
    * слово root тут не подходит, надо найти что-то типа origin как пару для mirror
  * перенос knoxel'ей внутри пространства и между пространствами
    * через drag'n'drop
      * с возможностью прервать операцию escape'ом
      * с возможностью прилепить ghost к screenspace'у space'ом для перемещения на далёкие расстояния и в другие пространства
    * рефакторинг параметров для addRect, spawnGhostRect, onGhostRectMoved
    * рефакторинг логики onGhostRectMoved для упрощения и наглядности
    * багфикс: попытка перемещение rect'а drag'n'drop'ом на малое расстояние приводит к проваливанию в его пространство
      * в итоге была переделана вся система перемещений и завязана на space/escape. подробности в readme.
    * багфикс: создаю knoxel для текущего space root, захожу в него, пытаюсь переместить
      * визуально действие по перемещению прерывается, но при обновлении space'а оно оказывается применённым
      * причина в том, что в этой ситуации в DOM'е существует 2 элемента с одинаковым id: spaceRoot и перемещаемый rect
        * надо на концептуальном уровне решить что делать с этими id
          * есть идея просто-напросто не отрисовывать knoxel с тем же id, что и у spaceRoot
            * в итоге так и сделал - посмотрим к чему это приведёт
* перевод knoxel'ей из worldspace в screenspace и обратно
  * в первую очередь подумать нужно ли это вообще или обойдёмся тем что уже есть
  * по итогам размышлений мысли следующие
    * не видно смысла в особом статусе screenspace'а.
    * если позволить делать интерактивное управление из одного пространства в другом,
    * то аналог скринспейса можно соорудить из простых knoxel'ей.
    * по факту сейчас screenspace нужен только для глобальных элементов управления:
      * space back arrow
      * save/load file (когда потребуется)
* способ управления порядком следования rect'ов в сцене
  * чтобы можно было удобно управлять кто кого перекрывает при отрисовке
  * по сути эту функцию может выполнять взятие и установка на место knoxel'я в режиме перемещения
    * можно пользоваться двойным нажатием space для вывода knoxel'я на верхний уровень отрисовки
    * единственное, что мешает этому сейчас, - это смещение ghost'а относительно knoxel'я при старте перемещения
      * фиксим эту проблему
      * и также рисуем специальным образом knoxel, для которого начато перемещение
        * stroke-dasharray="0 16" stroke-linecap="square"
      * отрефакторить работу с ghost - урегулировать новый функционал
        * в том числе отладить сложные случаи работы с knoxel'ями одного и того же knyte'а
          * сейчас там нет критических багов, но всё выглядит странно и сделано быстрыми хаками
        * подумать что делать с возможностью создавать "пространственные острова"
          * когда в мастер-пространстве создаёшь 2 knoxel'я
          * и потом вкладываешь их один в другой
          * в итоге если выйти из них через space back в мастер-пространство, то обратно в них уже не попасть
          * решение
            * в итоге для полного контроля над пространством нужно сделать 3 внешние ui-кнопки
              * space back - уже есть
              * space forward - действие обратное space back.
                * то есть возврат обратно в пространство, из которого вышел по space back
                * при этом последовательность space forward'ов обнулится, если войти в новое пространство
                  * это аналогично работе undo/redo в текстовом редакторе
              * space map - карта всех связанных через пространство knoxel'ей
                * чтобы можно было видеть все knoxel'и пространства и образованные ими острова
            * реализация
              * space forward
                * нарисовать в вёрстке
                * подправить функционал space back
                * прикрутить функционал space forward
              * space map
                * нарисовать в вёрстке
                * придумать как вписать в концепцию пространства
                  * добавляем третий особый knoxel в knoxel space
                    * в дополнение к master-knoxel и mirror-knoxel
                    * он будет называться spacemap-knoxel
                      * его контент генерируется при входе в него автоматически
                      * алгоритм генерации контента группирует все knoxel'и по связным группам
                        * такие группы называются островами
                      * таким образом из spacemap можно перейти в любой knoxel
                        * не зависимо от того, связан он с островом master-knoxel'я или нет
                * базовый реализовать функционал
                * довести фичу до законченного вида
                  * не всегда разделение на острова идёт корректно
                    * бывает, что появляются странные острова с одним knoxel'ем
                    * или один и тот же knoxel входит сразу в несколько островов
                      * по всей видимости это происходит от того, 
                      * что не любой knoxel может стать родоначальником острова.
                      * надо, чтобы в пространстве knoxel'я были другие элементы.
                      * если же он сам пустой, но содержится в пространствах других knoxel'ей,
                      * то его нельзя брать за первый knoxel острова
                    * таким образом, выбирать первый knoxel острова нужно специальным образом
                  * наилучший способ работы кнопок навигации при совместном использовании
                    * space map, space back, space forward
                      * в итоге space map получил поведение шортката для особого space map knoxel'я
                      * в целом его пространство ведёт себя как пространство стандартного knoxel'я
        * пересмотреть весь код и сделать его более логичным и понятным
          * потому что последние изменения для управления слоями порядком запутали логику кода
* оценка целостности логики управления пространством
  * что делать с ситуацией, когда knyte-пространство root space knoxel'я содержит в себе его самого?
    * описание проблемы
      * чисто технически получается, что в сцене 2 элемента с одинаковым id
      * поэтому как быстрое решение была отключена отрисовка такого knoxel'я внутри его пространства
      * ссылка на код:
        * if (knoxelId === newKnoxelId) // don't show knoxel inside itself
      * это приводит к эффекту исчезания и появления knoxel'ей при переключении space root'а.
      * нужно подумать как можно иначе решить эту проблему, чтобы всё работало проще и нагляднее.
    * решение
      * использовать в spaceRootElement не .id, а .dataset.knoxelId для хранения соответствующего knoxelId
        * таким образом можно избежать технического конфликта идентификации
        * такое логически допустимо, потому что .id используется для knoxel'ей внутри spaceRootElement
      * в итоге убираем функционал don't show knoxel inside itself
      * решаем сопутствующие проблемы
        * если попытаться переместить по пробелу knoxel, который и внутри пространства, и является его root'ом
          * то начнутся глюки, потому что такая ситуация не обрабатывается логикой переноса
          * в итоге внесены изменения, которые учитывают новые варианты структуры пространства
        * если в пространстве несколько knoxel'ей с таким же knyte'ом как и у root'а
          * то при перещёлкивании между ними мы не видим разницы, как-будто ничего не происходит
          * раньше они хотя бы исчезали и появлялись, была видна какая-то динамика
          * вероятно, надо особым образом рисовать и управлять knoxel'ем, который является root'ом
            * в итоге решил рисовать скругление прямоугольника через rx
              * это не окончательный вариант, но самый простой в реализации
              * в дальнейшем при переходе от rect к комплексным геометриям для отрисовки knoxel'ей
                * можно опдумать о более наглядном способе показать самовложенность knoxel'я
  * не всё понятно с функцией перемещения knoxel'я
    * когда надо переместить его внутри того же пространства, то всё просто и наглядно
    * когда knoxel в другом пространстве, где не виден gosted knoxel, возможны ситуации
      * при завершении операции не совсем понятно что произошло именно перемещение, а не копирование
      * при отмене операции не совсем понятно, что ghost knoxel остался на старом месте, а не удалён
    * решение
      * можно добавить специальную навигационную кнопку, которая покажет пространство ghost host knyte'а
        * на случай, если пользователь забыл откуда взял knoxel'и для переноса
        * и не понимает что с ними делать: копировать, перемещать или отменять операцию
      * вариант интерактива 1
        * onmousedown рисуется host-пространство
        * onmouseup возвращается отрисовка актуального space root'а
      * вариант интерактива 2
        * кнопка является шорткатом для перепрыгивания в host-пространство
        * вернуться обратно после просмотра можно по кнопке space back
    * реализация
      * в итоге сделан второй вариант как наиболее унифицированный с имеющимися решениями
  * по логике работы space map из него невозможно вытащить knoxel в другое пространство
    * логика сбора связей работает на knyte'ах, но отрисовка происходит по knoxel'ям
      * то есть не совсем понятна для чего рисуется карта и как определяются острова
        * разобравшись, я понял что остров - это не тот набор knoxel'ей, в которые можно попасть,
        * а это набор связанных knoxel'ей. при этом пока что мы можем ходить только в одном направлнии связи.
        * то есть может быть ситуация, что knoxel включён в остров, но в него нельзя попасть
        * пользуясь стандартными средствами навигации.
        * в перспективе можно развить инструменты так, чтобы можно было перемещаться по всем knoxel'ям острова.
    * особенности работы функций редактирования пространства в space map
      * создание knoxel'я внутри space map
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * копирование knoxel'я внутри space map
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * перенос knoxel'я внутри space map
        * визуально перенос не производится, так как происходит buildSpaceMap при обновлении вида пространства
          * не перестраиваем space map при вызове setSpaceRootKnoxel в целях обновления пространства
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * копирование knoxel'я в space map из любого другого пространства
        * пока нет связей, есть визуальная путаница, но после реализации связей структура пространства будет ясна
      * перенос knoxel'я из space map в другое пространство
        * работает адекватно
      * перенос knoxel'я из другого пространства в space map
        * на данный момент это действие отрывает knoxel от родного острова
        * но если переместить его же внутри space map, то никакого отрыва не будет.
        * нужно чтобы при любом варианте начала перемещения проиходило одно и то же действие
          * knoxel должен просто перемещаться в пространстве space map'а без смены host knoxel'я
    * нужно добавить визуализацию вложенностей пространств через стрелки
      * иначе совершенно не понятна структура островов и карта выглядит бессмысленной.
      * описание проблемы
        * стрелки должны быть отдельным типом объектов, отличным от векторов, которые появятся в перспективе.
        * на уровне отрисовки стрелки и векторы одинаковы, но на уровне логики они разные.
        * в space map нет смысла отображать knoxel'и в виде векторов
          * игнорируются все связи между knoxel'ями, кроме вложенностей
      * реализация
        * обобщённый функционал отрисовки arrow между rect'ами в условиях перемещения
          * arrow между arrow пока не нужны
          * создание arrow фиксированного цвета
          * обновление формы arrow при перемещении rect'ов
        * рефакторинг arrow - чтобы её концы были в центре rect'ов, а не по левому верхнему углу
        * прикручивание arrow к rect'ам в space map
    * перенос и копирование knoxel'я space map в пространства других knoxel'ей
      * нужно подумать возможно ли такое
        * и если нет, то запретить на уровне интерфейса
      * так как space map - это особый knoxel, выпадающий их общей концепции
        * запрещаем его перенос и копирование в какие-либо пространства
      * попутно обнаружилось, что если переносить knoxel из space map в другой knoxel
        * то knoxel начинает принадлежать сразу 2 пространствам: старому и новому,
        * потому что host определяется неправильно и из него ссылка на knoxel не удаляется.
        * но по концепции пространств knoxel в один момент времени может находиться
          * не более чем в 1 пространстве, не считая пространство space map'а.
        * решение - запретить перемещать любые knoxel'и из space map в другие пространства
  * не хватает возможности удаления knoxel'ей и knyte'ов для полного набора операций
    * решение должно обязательно избегать проблемы контроля того, что именно удаляется
      * как минимум не понятно удаляется только knoxel или весь knyte - должно быть однозначное правило
    * сразу приходят сопутствующие вопросы
      * какое удаление будет применяться по умолчанию?
      * что делать, если для knyte'а удалили все knoxel'и и он больше не имеет визуального представления?
      * как просто удалить все knoxel'и для заданного knyte'а?
    * в голову пришло необычное решение
      * вместо удаления можно перетаскивать ненужные knoxel'и на остров-мусорку
      * у ненужных knoxel'ей обрезаются все связи, очищается весь контент и они убираются в отдельное пространство
        * и это пользователь делает вручную или с помощью собственных кастомных алгоритмов,
        * потому что в общем случае корректное автоматическое отвязывание реализовать нельзя
  * обдумать функционирование space map
    * создание mirror-knoxel'я на старте уже не выглядит необходимым для взгляда со стороны на master-knoxel
      * благодаря наличию space map knoxel'я принудительное создание зеркала уже не нужно
    * оформить противоречия в текущей концепции space map'а
      * не очень понятно зачем нужно создавать и копировать knoxel'и внутри space map
        * если изначально он создавался для обзора пространственной структуры
      * не понятно почему в space map добавляются точно те же knoxel'и, что и в других пространствах, а не их копии
        * ведь это нарушает принцип что knoxel должен содержаться не более чем в 1 пространстве
      * может быть есть смысл прийти к принципу, что knoxel всегда должен содержаться в 1 и только 1 пространстве
        * тогда придётся вернуть mirror-knoxel и пересмотреть принципы работы space map
    * возможное решение
      * попробовать сделать space map для knyte'ов, а не для knoxel'ей
      * создать полную копию space как space2
      * удалить из space2 старую реализацию space map
      * написать с нуля новую реализацию
        * в которой space map - это такой же knyte с knoxel'ями
        * но у которого автоматически обновляется space при каждом изменении knyte space'а
        * поправить трейс arrow - чтобы они не перекрывали rect'ы
        * прятать arrow когда не отображается spacemap
        * решить как в spacemap будут себя вести knoxel'и оригиналы и дубликаты для knyte'ов
          * knoxel'и оригиналы можно создавать прямо в spacemap без проблем.
          * пока что концепция spacemap рассчитана на то, что каждый knyte представлен одним единственным knoxel'ем,
            * но в концепции обобщённого knoxel-пространства можно создавать дополнительные knoxel'и для knyte'ов.
            * надо подумать как это можно разрулить оставаясь в рамках правил spacemap'а.
              * в итоге разрешено делать перенос и копию knoxel'ей, для них создаются knyte-based arrows.
              * с одной стороны это не нарушает общую концепцию пространства и все функции разрешены,
              * с другой стороны можно легко навертеть очень запутанную структуру.
                * время покажет как лучше это всё организовывать, пока оставим так.
        * подобрать оптимальную цветовую схему
          * сейчас схема читаемая, но очень страшная. надо сделать более гармоничную.
          * вроде бы получше стало, жить можно, едем дальше.
        * сравнить поведение spacemap'ов в реализациях space/ и space2/
          * понять какое из них более адекватно потребностям пользователя
          * по факту проверки space2/ гораздо адекватнее и удобнее
            * поэтому переходим на него как на главное решение
        * рефакторинг применения spacemap и onKnoxelSpaceChanged
          * чтобы spacemap knoxel максимально гармонично вписывался в общую концепцию knoxel'ей
        * реализовать arrow у которого initial === terminal
          * то есть наглядно отрисовывать связь rect'а самого на себя
            * решил сделать по-простому - нарисовать arrow внутри rect'а, а не вести по внешнему контуру
            * для текущей ситуации пойдёт, а в будущем можно переделать в зависимости от ситуации
          * заодно нашёл и пофиксил дублирование при создании arrows
        * более наглядное отображение arrow - соединять не центры, а края rect'ов
          * удалось реализовать точное позиционирование стрелок с помощью модуля intersect
        * новые мысли про жизненный цикл knyte'ов и knoxel'ей
          * исходя из базовой концепции можно создавать knyte'ы
            * но нет универсального и удобного способа их удалять
          * так же для каждого knyte'а должен существовать как минимум 1 knoxel для отображения и манипуляций
            * но можно создать и много knoxel'ей - каждый в своём контексте и со своими настройками
            * при этом легко наплодить множество мусорных knoxel'ей для одного единственного knyte'а
            * чтобы избавляться от ненужных knoxel'ей, можно ввести операцию объединения knoxel'ей одного и того же knyte'а
          * получается, что изначально knyte создаётс с одним единственным knoxel'ем
            * затем этот knoxel может быть расщиплён для создания большего количества отображений knyte'а
            * а когда нужно сделать меньше отображений для knyte'а, то его knoxel' могут быть объединены
          * есть смысл переделать всё управление под новую концепцию, добавив функцию объединения
          * первым дело реализуем функцию объединения на случайном шорткате
            * описание работы
              * объединение действует из режима ghost
              * если наводим ghost на knoxel, с которым его можно объединить, то показывается подсказка
              * alt+space объединяет target-knoxel и ghosted knoxel
            * визуальная отработка интерфейса
            * отработка на уровне логики
            * рефакторинг для перехода от концепции add/remove к концепции divide/join в коде
          * далее заменяем функцию копирования (ghost: alt+click) на функцию расщипления
            * срабатывает при alt+click на knoxel'е - добавляет рядом второй knoxel для того же knyte'а
          * в итоге доводим до ума весь комплекс шорткатов, чтобы они имели смысл и были удобными
            * спроектировать
              * отделить операции divide/join от ghost-режима в отдельный bubble-режим
                * который запускается по кнопке enter
              * при нажатии enter из bubble-режима на пустом месте делается divide
              * при нажатии enter из bubble-режима на другом knoxel'е того же knyte'а делается join
              * при нажатии esc из bubble-режима происходит выход из этого режима
              * при нажатии enter из bubble-режима на том же самом knoxel'е происходит выход из этого режима
            * реализовать
              * функционал на кнопках
              * интуитивно понятное отображение
                * разрулить особый кейс, когда делается join для space root knoxel'я
                  * запретить join для space root'а
                  * если нужно убрать knoxel, сначала назначается другой space root
                * перейти от кешированного mouseoverKnoxelId на актуальный через document.elementFromPoint
                  * это поправит следующие баги:
                    * если создать knoxel и сразу нажать space
                      * то ghost создастся не для него а для того, что лежит под ним,
                      * потому что из-за отстутствия события onMouseOverRect не обновится mouseoverGhostKnoxelId
                    * если сделать join для knoxel'я, mouseoverKnoxelId всё равно будет указывать на него
                      * не смотря на то, что он исчез
                * в bubble-режиме действуют следующие правила особые отображения для knoxel'ей:
                  * active bubble полупрозрачный и с пунктирным контуром
                  * knoxel'и с тем же knyte'ом но не равные исходному - с пунктирным контуром
                  * всё остальное рисуется без изменений
            * обновить описание управления в readme
          * переосмыслить реакцию на space на пустом месте
            * интерпретация пустого места в ghost- и bubble- режимах должна быть идентичной
              * в целом получилось, что они ведут себя примерно одинаково, концептуальных противоречий не замечено
            * багфикс - если взять ghost из space root и переместить его в 2 разных knoxel'я
              * то space root knoxel окажется сразу в 2 пространствах
                * что противоречит концепции пространства как контейнера для knoxel'ей
            * багфикс - если взять bubble от space root
              * навести его на knoxel другого knyte'а и нажать enter
              * будет произведён divide actual bubble, хотя по логике вещей ожидается terminate
            * багфикс - некорректная отрисовка и поведение selfcontained-knoxel'я в bubble-режиме
              * он не должен быть пунктирным, потому что он не может быть уничтожен
              * при enter на нём не должен создаваться новый knoxel, а должен происходить terminate
          * переосмыслить скругление rect'а при отрисовке knoxel'я совпадающего со space root'ом
            * я не думаю, что в общем случае мы можем менять форму rect'а
            * да и сама визуализация не особо репрезентативная
              * в итоге перешёл от скруглений к утончению обводки
                * думаю, как временный вариант - вполне нормально
* фиксируем полезное допущение
  * пусть содержимое пространства любого knyte'а умещается в пределах экрана браузера
  * тогда не треуется делать множество дополнительных инструментов для работы в большом пространстве
  * и можно уделить основное внимание локальной реализации взаимодействия функций в семантической среде
  * когда все основные функции локального knoxel space'а будут готовы
    * можно будет наложить на них концепцию "широкого пространства", выходящего за границы экрана
* реализовать отрисовку knoxel'ей
  * innerspace
    * рекурсия отрисовки внутреннего пространства knoxel'я
      * решить как будет задаваться размер knoxel'я в каждом пространстве
        * пока что видно два основных варианта:
          * автоопределение размера по размеру внутреннего пространства
          * ручное задание собственного размера в каждом пространстве, храненить рядом с позицией
      * отрисовка внутренностей без скейлов
        * погружение всего на 1 уровень внутрь
          * автоопределение размеров по содержимому
          * игнорирование цикличных кейсов, то есть расчитано только под древовидное ветвление
          * особая отрисовка для knoxel'ей space map'а
        * погонять функционал и понять что ещё может минимально понадобиться для первой демки
        * специальное отображение пространств space map'а
        * отображение пространств с неограниченной вложенностью для древовидного вида связности
          * основная реализация
          * поддержка иконок внутри пространств
        * специальное отображение пространств для кольцевой и самосодержащейся вложенности
        * выравнивание размера пространств по левому верхнему краю
          * не только по правому нижнему как это сделано сейчас
          * подпространства не должны вылазить за левый верхний край
          * подпространства не должны иметь неоправданную пустоту в левой верхней части
        * понять как быть с циклическими вложенностями
          * у них есть тенденция постоянно расширяться в пространстве
          * глядя на них, не понятно что там происходит
            * благодаря удачной системе автоопределения размера пространств циклические вложенности на создают проблем
        * вероятно, есть смысл рисовать шейпы внутри активных knoxel'ей с более тонкой рамкой
          * чтобы было понятно, что это отображения, а не активные элементы
          * тогда надо придумать другое отображение для selfcontained knoxel
            * чтобы ему не приходилось утончать обводку, тем самым внося путаницу в интерфейс
            * в итоге реализовано наложение крестообразного выделения на rect knoxel'я
          * провести эксперимент с изменением толщины обводок внутри активных knoxel'ей
            * реализовал, посмотрел - выглядит отлично. оставляем так.
        * иногда при выборе пространства как ghost/bubble нельзя войти по клику в другое пространство
          * вся проблема в том, что не на все элементы выставляется pointer-events: none
        * при нажатии space/enter на selfcontained knoxel должен появляться ghost/bubble строго поверх него
          * а не по середине курсора. такое поведение мешает управлять порядком слоёв
        * подумать что делать при переносе ghost/bubble между пространствами
          * у них может меняться актуальное отображение в зависимости от space root'а
            * а сейчас это не учитывается, в итоге можно видеть на превью одна, а в пространство воткнуть другое
          * решение: надо пересоздавать визуализацию для ghost/bubble при каждой смене пространства
            * таким образом в каждом пространстве будет показываться соответствующее ему отображение knoxel'я
          * реализация
            * ghost
            * bubble
     * по завершению вышеперечисленных этапов можно организовать демонстрации текущего состояния системы
  * information record
    * продумать саму концепцию внедрения контента внутрь svg-объектов
      * вероятно, нужно всё делать через foreignObject и дать возможность задавать knoxel'ям произвольный html-контент
      * также нужно изучить возможности современных стандартов svg и их взаимодействие с html и css
        * рассмотреть вариант перехода с текущей версии svg 1.1 на самую свежую
          * узнать какая вообще версия является последней
          * проверить совместимость с браузерами
          * понять какие профиты будут от новой версии
          * оценить масштаб переделок
            * в итоге оказалось, что приемником актуального svg 1.1 станет svg 2.0, который ещё не готов
            * поэтому остаёмся на svg 1.1
        * выработать наиболее эффективный способ внедрения обобщённого html+css+js внутрь svg-элементов knoxel'ей
          * делать ли оптимизацию структуры svg-елементов под контент (пусто, однострочный текст, foreignObject)
            * или везде использовать foreignObject, чтобы не перестраивать их структуру при каждом изменении контента?
          * стресс-тесты показали, что добавление foreignObject к 10000 rect'ов не приводит к сильному замедлению сцены
            * соответственно можно использовать унифицированную модель rect'а для всех ситуаций
          * для начала делаем конкуретный способ отрисовки контента, чтобы на нём уже пробовать все идеи
            * конкуретный - это значит что если у knyte'а есть information record, то рисуется только он
              * в противном случае рисуется innerspace
            * реализация на базовом уровне
            * автоопределение размера контента и выравнивание по нему foreignObject'а
              * через element.getBoundingClientRect
              * в общем случае это невозможно, поэтому перейдём к ручному заданию размеров каждого foreignObject'а
            * выравнивание размера rect'а по foreignObject'у
              * при этом rect не должен быть меньше заданных минимальных размеров visualTheme.rect.defaultWidth/Height
          * как выравнивать контент внутри rect'а для лучшей читаемости?
            * особенно важно в том случае, если контент по размеру оказался меньше rect'а
              * общая система задаёт размер foreignObject'а, точно вписывая его внутрь обводки rect'а
                * на этом её работа заканчивается
              * каким образом отображать информацию внутри заданных рамок foreignObject'а - это уже решает сам контент
          * как вписывать foreignObject в rect?
            * накладывать его точно по размеру - и тогда он будет перекрывать внутреннюю часть обводки
            * или утопить в обводку, чтобы он был точно внутри неё
            * или делать некий стандартный отступ от обводки, чтобы контент foreignObject'а не лепился вплотную к обводке
              * в итоге решил утопить контент в обводку: foreignObject.w = rect.w - stroke.w
              * это самый простой в реализации и приемлемый по внешнему виду вариант
          * как определять размер foreignObject'а и rect'а для вписываемого в них контента?
            * на данном этапе задаём размер вручную
            * попытки автоопределения размера в общем случае не работают
              * можно будет это реализовать потом, в рамках специальных редакторов для контента различных типов
          * оставить rect fill color или заменить его чем-то на основе foreignObject'а?
            * обводка всегда остаётся за svg rect'ом
            * но встаёт вопрос о том, кто будет отрисовывать внутренности knoxel'я - rect или foreignObject?
              * rect всегда будет иметь цвет, который будет определять цвет пространства
              * foreignObject может иметь цвет фона или нет, может иметь фон любого размера
                * это уже вопрос отображения конкретной информации, а не общая системная функциональность
          * реализовать базовое отображение произвольного html-контента внутри foreignObject'а для всех rect'ов
            * функция назначения контента и размера knyte'у по ghost knoxel id
              * шаблон контента для простого центрированного текста
                * <div style="display: flex; height: 100%; justify-content: center; align-items: center;">My Text</div>
              * setGhostKnуteInformationRecord - результат
            * багфикс перетаскивания ghost/bubble в случае, если space/enter был нажат над foreignObject'ом
              * сейчас их offset'ы глючат не смотря на применение pointer-events: none
            * выяснить реально ли нужен pointer-events: none для foreignObject'ов
              * на данный момент никакого смысла в этой настройке нет
              * вероятно, что-то изменится когда будет решаться вопрос с интерактивным контентом
              * а пока что мы работаем над статическим контентом с чисто информационной нагрузкой
          * как сочетать отображение foreignObject и innerspace для rect'а?
            * в итоге получается есть 2 факта совмещения: по изображению и по размеру
              * по изображению можно совмещать так, что контент foreignObject'а будет фоном для отрисовки innerspace'а
                * то есть получается слоёная структура knoxel'я: colored rect, foreignObject content, innerspace
            * по размеру foreignObject расценивается просто как ещё один вписанный в knoxel rect
              * в соответствии с его x, y, w, h он расширяет общее пространство, но не обязан занимать его целиком
    * реализация отображения контента, заданного из вне через html-код
      * включить отладочный контент, который будет работать для всех knoxel'ей
      * реализовать механизм отрисовки rect'ов с foreignObject'ами
        * на уровне вложенных rect'ов
        * на уровне space root'а
        * проверить работоспособность record view на циклических пространствах
          * обновлять space root foreignObject после каждого создания нового knoxel'я
            * в остальных ситуациях он уже обновляется сам благодаря скрытым вызовам setSpaceRootKnoxel
          * подобрать более подходящее обозначение для selfviewed knoxel
          * уточнить правило отображения контента для spacemap knoxel
            * в итоге просто решено не рисовать контент в knoxel'ях, которые отображаются иконками
            * таким образом, отрисовка контента и подпространств происходят на равных правах
        * провести рефакторинг по накопившимся проблемам
          * завязать getRootByTarget на className mouseOverRect, а не на первый попавшийся непустой id
            * потому что в произвольном контенте вполне могут быть различные id
          * в rect.add перейти от flat к type-параметру
      * контекстное редактирование контента в foreignObject'ах и назначение цвета rect'ам
        * эксперименты с редактором contentEditable на уровне произвольного хтмл-кода
          * теоретически это безграничные возможности в визуальном редактировании хтмл-вёрстки
          * на практике это очень неудобный редактор, в котором даже перевод строки в тексте - это суровая проблема
          * он не даёт ощущения контроля, все манипуляции выполняются в слепую
            * и очень сложно понять что нужно жать, чтобы получить то, что хочешь
        * принять решение о дальнейшей разработке редакторов
          * в конечном счёте редакторы должны быть реализованы через интерактивные knoxel'и
          * но пока система не достаточно развита для этого можно реализовать для развития базового функционала
            * редакторы за пределами концепции knoxel space, через классические интерфейсные элементы веба
        * редакторы information record'а на уровне простого однострочного центрированного текста
            * с автоматическим определением размера итогового rect'а
              * поразмыслив, я понял, что на ранней стадии для тестирования больше ничего не требуется
              * реализация общей системе типизации, редактирования и отображения данных пока преждевременна
            * вызывается по enter
              * для этого перевести drop/join bubble на shift+space/space
            * представляет из себя простой prompt с текстовой строкой
            * редактирует строку, которую потом прогоняет через специальный viewer
              * для оптимального отображения в виде html-объекта
            * автоопределение размера идёт по спрятанному элементу шириной во весь экран
              * решение с ограниченными возможностями, но подходящее как временное для данной упрощённой ситуации
        * редактор размера
          * вызывается по alt+enter
          * представляет из себя простой prompt с кодом вида {w: 100, h: 50}
        * редактор цвета
          * вызывается по shift+enter
          * представляет из себя простой prompt с цветом вида #ffc0ed
      * отключить отладочный контент и проверить работоспособность на произвольном контенте, создаваемом в рантайме
      * пересмотреть управление, сделать более удобным
        * по результатам обновить контролы в readme
        * оказалось удобно, когда наало и завершение определённой операции привязано к одной кнопке
          * например, Space для ghost-режима или KeyB для bubble-режима
          * а сочетания shift+space, alt+space неудобны
          * то же самое касается вызова редакторов данных/цвета/размера
      * отключение рандомного автоназначаемого цвета
        * установить цвет knoxel'я по умолчанию и дать возможность его изменять
        * подправить цветовую тему в соответствии с новым внешним видом пространства
        * сделать более удобный диалог выбора цвета с набором наглядных цветов как вариантов
      * возникнет ситуация, что пустые knoxel'и для разных knyte'ов будут выглядеть одинаково
        * потому что для только что созданного knoxel'я будет использоваться один стандартный контент
          * и разные knyte'ы могут иметь одинаковый контент
        * надо будет найти способ быстро понимать какие knoxel'и относятся к одному и тому же knyte'у
        * решение - включать bubble-режим и смотреть по обводке кто связан с текущим bubbled-knoxel'ем
          * чтобы этот режим работал во всех ситуациях, нужно selfcontained knoxel тоже делать пунктирным в bubble-режиме
            * но он всё равно будет выглядеть неуничтожаемым благодаря метке selfcontained
    * установка шрифта Menlo по умолчанию для всего веб-приложения
      * в итоге решил не подключать какие-то особые шрифты, а использовать стандартные системные
      * так как пока нет цели делать унифицированную кросс-платформенную систему
        * то пусть будет решение, которое оптимально работает на macos
        * другие платформу будем рассматривать по мере того, как они станут актуальны
  * vector
    * спроектировать как совмещать rect и arrow отрисовки в рамках одного knoxel'я
      * добавить shape для связи в rect element
      * реализовать возможность соединять стрелкой указанные knoxel'и
        * соединение через консоль через knoxelVectors
          *  knoxelVectors['']={initialKnoxelId: '', terminalKnoxelId: ''}
        * корректное поведение rect'а и arrow во всех режимах
          * точное позиционирование концов стрелки по краям initial и terminal rect'ов
            * с учётом рекурсивной вложенности пространств
          * во вложенных пространствах рисовать более тонкую стрелку - аналогично обводке
          * реализовать гениальную по своей эффективности идею со связями
            * первым делом решить проблему точного определения размеров rect'ов при подсоединении к ним стрелки
              * старый способ из spacemap через knoxelRect.getElementSize уже не прокатывает
                * потому что в момент расчёта стрелок не все элементы помещены в сцены
                * да и концептуально некоторые элементы вообще в сцене со своими идентификаторами появиться не могут
              * для активных knoxel'ей пространства
              * для рекурсивных отображений innerspace'ов
            * сделать rect соединительным joint'ом между initial и terminal частями arrow
              * и позиция этого joint'а не выставляется автоматически, а перемещается вручную
              * это радикально упрощает программинг и даёт дополнительные возможности пользователю
                * надо подправить getArrowPointsByRects и getArrowPointsByKnoxels на основании бекапов
          * следующие вопросы решаются автоматически - by design
            * как входить в подпространство стрелок
            * как вызывать редактор record'а для стрелок
            * как отображать selfcontained для стрелок
          * интерактивное создание и переназначение связей между knoxel'ями через кнопки z и x
            * модифицирует только knoxelVectors, пока что без какой-либо связи с уровнем knyte'ов
              * первая версия на стандартном ghost без частичных vector'ов (когда не все endpoint'ы определены)
              * реализация поддержки частичных vector'ов
              * разрулить ситуации частичного и полного замыкания связи на саму себя
                * когда initialKnoxelId и/или terminalKnoxelId равны jointKnoxelId
              * разрулить ситуацию, когда указанный initialKnoxelId/terminalKnoxelId не найден в текущем space'е
              * поправить определение размеров для self-connected arrows и broken arrows
                * выступающие части стрелок не учитываются в размере и в итоге могут вылазить за гарницы пространства
                  * в итоге сделал метки спец-knoxel'ей поменьше, чтобы они влазили в стандартную обводку вокруг rect'ов
              * вторая версия на специальных объектах: initial ghost, terminal ghost
                * базовый функционал
                * dotted для arrow изменяемого knoxel'я
                * selfcontained - отключить, так как связи неограниченного с ограниченным не имеют смысла
                * interspace
          * уменьшение rect'а, если у knoxel'я указаны параметры vector'а, но при этом у его knyte'а не задан record
            * 32х32 --> 10х10
          * багфикс - ошибка при divide'е knoxel'я со связями в innerspace
            * как в родном пространстве, так и в другом
              * проблема была из-за того, что во время divide knoxel'я создавался и сразу удалялся knoxel
                * для arrows которого потом на следующем кадре вызвался updateArrowShape
                  * конечно же, подходящих rectId для него в этот момент уже не существовало
              * поправлено отключением обновления пространтсва после divide knoxel
                * оно в этой ситуации не имеет никакой необходимости - как и при добавлении нового knoxel'я в space
          * придумать как интерпретировать ghost-mode для стрелок
            * в рамках host space это перемещение arrow joint'а для knoxel'я
            * в режиме interspace это перенос knoxel'я в другое пространство с обрывом связей
              * или же возврат в host space после некоторого путешествия по другим space'ам
            * во время отрисовки ghost'а должы быть видны актуальные для данного пространства связи
              * host space
              * interspace
          * придумать как интерпретировать bubble-mode для стрелок
            * пофиксить багу с тем, что divide knoxel всегда создаёт rect'ы со сплошным контуром
              * а у них должен быть пунктирный контур, так как к ним можно применить join knoxel
            * вообще игнорировать arrow для bubble-элемента
              * в том числе и не уменьшать его размер, если у active bubble knoxel'я имеются атрибуты arrow
            * проверить общее поведение во всех ситуациях
            * когда происходит join для knoxel'я, то у него могут быть связи: initials, terminals и joint
              * по базовой концепции объединения пузырьков в результате join'а внешние связи не должны исчезать
                * но если сам knoxel является связью, то эта связь должна исчезнуть
              * в итоге получаем такие требования к функционалу
                * связь joint knoxel'я должна исчезать после join'а и удаляться из knoxelVectors
                * initials и terminals связи joint knoxel'я должен принимать на себя bubbled knoxel
                  * чтобы не происходило обрывов связей
    * спроектировать vector'ы между knyte'ами
      * команда соединания knyte'ов vector'ом
      * наложение ограничений на соединение knoxel'ей vector'ами с учётом структуры knyteVectors
      * реализовать все вариации knoxel vector'ов на уровне интерфейса в соединении с knyte'ами
        * привязка knyte vector'ов к initial ghost, terminal ghost
        * режимы initial bubble, terminal bubble на кнопках KeyN, KeyM соответственно
          * базовый режим
          * setArrowBubbledMode
        * привязка knyte vector'ов к initial bubble, terminal bubble
        * разрулить нажатие KeyN/KeyM на неподходящем knoxel'е
          * должно быть такое же поведение, как при нажатии на пустом месте - аналогично KeyB
    * подумать что делать со связями и особыми стрелками в spacemap-knoxel'е
      * в принципе связи в spacemap выглядят и работают нормально, может быть даже для чего-то пригодятся
        * но смущает, что стрелки связей очень похожи на стрелки вложенности в пространства
      * надо придумать как визуально различать разные типы стрелок без ухудшения читаемости схемы
        * делаем просто другую форму маркеров у стрелок - этого будет достаточно на первое время
    * подумать что делать с изменением color, size, record для spacemap-knoxel'я
      * color можно менять вне зависимости от цвета spacemap-кнопки, который остаётся фиксированным
        * также надо привести форму кнопки spacemap в соответствие с формами других кнопок - сделать обводку
      * багфикс - при смене цвета knoxel'я нужно менять и цвета связанных с ним кнопок spaceBack/spaceForward
      * игнорировать size и record для spacemap
        * то есть туда можно записать какую-то инфу, как и в любой knoxel, но ничего из этого не будет показано
  * и всё вместе в любой комбинации
    * разделить size на 2 части:
      * record size задаётся для всего knyte'а, действует во всех пространствах
        * прописывается в record.size = {w, h}
        * определяет размер зафиксированного в {x: 0, y: 0} foreignObject'а для отображения record'а
          * как в режиме space, так и для recursive
      * knoxel collapse задаётся для конкретного knoxel'я и действует только в его host-пространстве
        * определяет показывать innerspace knoxel'я или схлопнуть его до размера иконки
        * определяется в knoxelViews[knoxelId].collapse
          * после интенсивных размышлений пришёл к выводу, что кастомный размер knoxel'я не имеет большого смысла
            * потому что в большинстве случаев нужно просто целиком его схлопнуть до минимальных размеров
              * при этом для кастомных размеров rect'а требуется clipping контента, который неоправданно сложен в разработке
    * реализовать назначение разных цветов стрелкам и обводке rect'ов
      * цвета могут быть 2 типов: цвет knyte'а и цвет knoxel'я
        * цвет knyte'а задаёт цвет фона, на котором рисуются record и innerspace
        * цвет knoxel'я задаёт цвет обводки rect'а и arrow
          * определяется в knoxelViews[knoxelId].color
    * ряд багфиксов и мелких правок
      * на уровне редактора вернуть центрирование текста по knoxel'ю для oneliner'ов
      * объединить visualTheme rect.recursive.strokeWidth и arrow.recursive.strokeWidth в recursive.strokeWidth
      * объединить visualTheme rect.strokeColor и arrow.strokeColor в knoxel.defaultColor
      * убрать отрисовку стрелки, когда нет связи
        * необходимо для корректной отрисовки ректов с прозрачным фоном
      * багфикс для пары особых кейсов отображения arrow
      * более логичное отображение для оборванных связей
    * багфикс - поправить разные смещения foreignObject'ов в разных пространствах
      * spaceroot, 1st level innerspace, 2+ level innerspace
      * смещения различаются на порядок толщины обводки, где-то она некорректно прибавляется/вычитается
        * после долгих размышлений решено переделать принцип позиционирования и выравнивания foreignObject'ов
          * теперь они не будут учитывать толщину обводки и будут рисоваться относительно базового размера и положения rect'а
            * то есть код типа x -= strokeWidth/2 и w -= strokeWidth для foreignObject'ов больше не понадобится
    * багфикс - после правки по foreignObject'ам размер oneliner'ов стал слишком маленький и на них наезжает обводка rect'ов
      * решение в том, чтобы на уровне редактора всем давать фиксированный отступ равный, например, visualTheme.rect.strokeWidth
    * составить список майлстоунов и внерить их в roadmap
      * чтобы было понятно какой функционал к каким этапам внедрения будет нужен
* реализовать интерактивное поведение knoxel'ей
  * редактор для написания многострочного форматированного через \t и \n текста
    * который можно интерпретировать в интерактивных блоках как код для выполнения
    * этапы реализации
      * универсальный диалог редактирования с выбором типа контента
      * к oneliner добавить форматированный текст
      * назначение и изменение форматированного текста в knyte.record'ах
      * довести удобство использования редактора до приемлемого уровня
  * редактор для написания html-кода для вставки в foreignObject'ы
    * тип будет называться interactive
  * модуль запуска кода из knyte.record'ов
    * желательно в отдельном потоке, чтобы это не стопорило навигацию в основном потоке
    * общая реализация
      * интерактивная кнопка для запуска вычислений
      * подключение блоков-параметров с кодом для запуска
      * запуск подключенного кода самым простым способом
        * без обработки ошибок - для ситуации, когда всё работает
          * с отображением статуса интерактивного блока (ready/working) и последнего вычисления (none/success/failed)
        * с обработкой ошибок транслирования и рантайма
      * добавление входящих параметров
      * добавление выходящих параметров
  * линейная связка интерактивных блоков, которые выполняются один за другим автоматически
    * упрощённый прототип перехода на knoxel-based run block'ах
  * условные переходы между связками
    * `прототип if else`
    * прототип switch case
  * перевод run block'ов на knyte-based
    * все изменения состояния knyte'а синхронизируются между всеми его knoxel'ями
    * состояния knoxel'ей не сбрасываютсяпри обновлении пространства
    * код запускается не из визуального блока knoxel.foreignObject, а из единого knyte-центра
      * доступность которого не зависит от видимости knoxel'ей из текущего space root'а
  * тестовые задачи
    * скорее всего на этом этапе понадобится сохранение/загрузка состояния системы
    * рассчёт числа Пи с высокой точностью без входящих и выходящих параметров
      * базовая реализация без внешних параметров
      * в отдельном потоке, чтобы не блокировать интерфейс долгими вычислениями
        * и желательно не иметь доступа к полному контексту системы (DOM, global js runtime, etc.)
      * входящий параметр - количество итераций для вычислений
      * выходящий параметр - результат вычислений
    * рассчёт другого трансцендентного числа с высокой точностью
  * оформить промежуточную спецификацию на созданный функционал
    * она же - тесты на правильность поведения системы
  * багфиксы по интерфейсу run block'ов
    * если у run block'а есть output parameter'ы, то после выполнения у него не отображается success
      * потому что сразу после назначения success происходит перестраивание всего пространства
        * чтобы отразить изменения во всех output parameter'ах
    * если во время выполнения кода вызвать обновление пространства, то его статус сбросится
      * например, если что-то передвинуть
        * это вызвано тем, что визуальный элемент run block'а пересоздаётся, а его статусы хранятся только внутри него
  * нелинейные конструкции связок
    * когда из одного елемента выходят сразу несколько потоков, выполняющихся параллельно
    * когда сразу несколько выполнявшихся параллельно потоков сходятся к одному элементу
  * общая концепция
    * фокуса ввода
    * интерактивные события
    * обработчики событий
  * найти способ оформить кнопки spaceBack, spaceForward, spaceHost как интерактивные knoxel'и
  * найти способ унифицировать поведение knoxel'я space map со всеми остальными knoxel'ями
    * и оформить его кнопку как интерактивный knoxel
* сохранение и загрузка для данных knyteCloud и knoxelSpace через 1 json-файл
  * при этом не обязательно делать его удобным для диффов гита
  * максимум что можно реализовать - это сортировку элементов по имени, чтобы не было большой пересортицы
    * в будущем система будет иметь свою историю изменений и диффы, поэтому аналогичный функционал гита не понадобится
* МАЙЛСТОУН-1: обучающий фреймворк
  * knoxelSpace как базовая структура для решения задач интерактивного программирования
    * вместо традиционной текстово-файловой структуры
* дополнительные интерактивные knyte'ы
  * по аналогии со spacemap нужно сделать vectormap для отражения всех связей выбранного knyte'а
  * может быть аналогичную вещь надо будет сделать и для knoxel'ей
    * без такой функциональности сложно следить что происходит со связями
  * модуль searchdata для поиска knyte'ов по record.data
  * подумать есть ли возможность реализовать vectormap, spacemap и searchdata на интерактивных knoxel'ях
  * реализовать редакторы не только для oneliner'ов, но и для многострочного форматированного текста, для кода (html/js)
    * показывать код в knoxel'ях как в текстовом виде с подсветкой, так и в виде интерактивного html
  * подумать как заменить кнопки spacemap/spaceback/spaceforward/spacehost на стандартные интерактивные knoxel'и
  * реализовать для KeyV нормальный диалог выбора цвета, как и для KeyC
  * разделить стандартные цвета между KeyC и KeyV
    * в KeyC будут те цвета, которые подходят для фонов rect'ов
    * в KeyV будут те цвета, которые подходят для обводок rect'ов и arrow
      * соответственно любой цвет из KeyV должен хорошо читаться на любом цвете из KeyC
* МАЙЛСТОУН-2: прототипирование отдельных модулей реальных приложений
* плановый рефакторинг
  * выстроить более простую, понятную и унифицированную логику в knoxelRect.add
    * заодно избавиться от дублирования кода между createShapes, createFigure, knoxelSpaceRoot.update
  * выделить всю логику из обработчиков вида function onXXX в отдельные функции
  * каким-то образом обобщить очень сходный код для activeGhost/Bubble, activeInitial/TerminalGhost/Bubble
  * при изменении knoxel.color перекрашивать не только обводку rect'а и линию arrow, но и маркеры на концах arrow
  * объединить knoxels, knoxelVectors и knoxelViews в knoxelSpace со следующей структурой
    * knoxelSpace[knoxelId] = {knyteId, vector: {initialKnoxelId, terminalKnoxelId}, collapse, color}
  * переименовать knyteVectors в knyteCloud
* множественное выделение knoxel'ей и совместимость с ним всех реализованных функций
* пространственная навигация по пространствам knoxel'ей
  * сюда же входит масштабирование и позиционирование содержимого knoxel'ей
  * по сути это концепция "широкого пространства"
  * решение вопросов перегрузки knoxel'ей информацией
    * что делать со слишком большим контентом, который нет необходимости показывать целиком?
    * что делать, если не нужно показывать 
      * контент
      * innerspace
      * и контент, и innerspace
* МАЙЛСТОУН-3: разработка комплексных приложений для реальных бизнес-задач
* хранение в системе всей истории изменений
* отображение диффов между любыми точками из истории изменений для любых групп knyte'ов и knoxel'ей
* хранение всей функциональности системы исключительно в структуре knyte'ов
  * без 
* реализация всех функций системы, для которых это в принципе возможно, через возможности самой системы
  * не прибегая к внешним надстройкам за пределами
    * knyteCloud на уровне хранения данных
    * knoxelSpace на уровне интерактивного интерфейса
* МАЙЛСТОУН-4: исследование концепции интерактивной базы знаний и семантического языка программирования